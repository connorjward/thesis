\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Mesh-like data layouts}
\label{chapter:mesh_data_layouts}

\pyop3 was created to provide a richer abstraction than \pyop2 for describing stencil-like operations over unstructured meshes.
Most of the innovation in \pyop3 stems from its novel data model.
Data structures associated with a mesh are created using more information about the mesh topology.
This lays the groundwork for a much more expressive DSL since more of the semantics are captured/represented.

\section{Data layouts for the finite element method}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange}
\end{figure}

\begin{figure}
  \label{fig:YYY}
\end{figure}

\begin{figure}
  \label{fig:ZZZ}
\end{figure}

The semantics for data kept on a mesh are not accurately captured by existing array abstractions.

% TODO does this go here? background?
Classic existing abstractions include N-dimensional array, ragged arrays and struct-of-arrays.

To provide a motivating example, consider the mesh shown in \cref{fig:two_cell_mesh_lagrange}. % P3 quad would look good
Degree 3 Lagrange elements have been used and these have 1 DoF per vertex, 2 per edge and 1 per cell.
DoFs are always stored contiguously per mesh point, and so the data layout for this mesh would look something like that shown in \cref{fig:YYY}.  % data layout of the mesh
It is clear that, due to the variable step size for each mesh point, an N-dimensional array (with N > 1) is a poor fit for describing the layout.
One could also view the data as just a flat array (figure ZZZ), but this loses the information about the mesh points.  % just show a diagram where nodes are indistinguishable
We can therefore conclude that mesh data layouts require a new abstraction for comprehensively describing their semantics: \textit{axis trees}.

\subsection{Axis trees}

From \cref{fig:YYY} it can be observed that the data layout naturally decomposes into a tree-like structure.
For every class of topological entity (i.e. vertex, edge or cell) there is a distinct number of DoFs associated with it.

Typically, this structural information is discarded.
\pyop3, however, is capable of capturing this information through using the concept of an \textit{axis tree}.

And axis tree is composed of a hierarchy of \textit{axes}, and each axis has one or more \textit{axis components}.

The notion of an \textit{axis} has already been well established by numpy.
If we consider a 3-dimensional numpy array with shape \pycode{(3, 4, 5)}, each dimension of the array is considered to be an axis.
One can for instance change the order in which the array is traversed by specifying the axes via a \pycode{transpose} call (e.g. \pycode{numpy.transpose(array, (2, 0, 1))}).

% axis, axis component
% labelled
% examples!
% mixed

\subsubsection{Computing offsets}

In the same way that the shape of a numpy array decribes how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses an ultimately flat array.
Indeed, in \pyop3 (flat) numpy arrays are used as the underlying data structure.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.

% layout algorithm

% we use pymbolic for describing the expressions

\subsection{Interleaving axis components}

% renumbering

\subsection{Ragged arrays}

% ---

% actually storing data in matrices and arrays

% ---


% OLD
% \subsubsection{Representing data layouts with DMPlex}
%
% DMPlex represents a mesh as a set of points where the points are divided into \textit{strata} (cells, edges, vertices, etc).
% These points are connected in a graph (Hasse diagram) and a rich set of queries can be used to determine the right adjacencies needed for things like the finite element method.
%
% In order to associated data with these mesh points, a typical PETSc application will construct a PETSc \ccode{Section}.
% These are simple CSR-like (?) data structures that encode a data layout by associating a particular number of DoFs with each mesh point.
% Sections are a powerful tool for describing data layouts but they have a number of limitations:
%
% \begin{itemize}
%   \item
%     Sections are fully ragged.
%     They only store DoF information per point in a completely unstructured way and are incapable of knowing, say, that every cell in the mesh stores exactly one DoF.
%     This can prohibit the compiler from making certain optimisations (e.g. loop unrolling) that it would have been able to do were it to know of a constant loop extent.
%     Additionally, this variable size increases memory pressure as redundant arrays of constant sizes need to be streamed through memory.
%
%   \item
%     DoFs per point are treated as a flat array.
%     This means that shape information is lost for, say, vector-valued functions.
% \end{itemize}
%
% With PETSc/DMPlex, the P3 DoF layout would be represented as shown in Figure~\ref{???}.
% % figure showing PetscSection info
%
% \subsubsection{Data layouts in \pyop2}
%
% \pyop2 takes a very different approach to describing data layouts to DMPlex.
% Firstly, it has no conception of what a mesh is and it deals solely with \textit{sets} and \textit{mappings between sets}.
% The rich query language provided by DMPlex is therefore unavailable and the task of determining the right adjacency maps is passed to the user.
%
% \subsection{What \pyop3 does}

  % start with P3?


% Introduce hierarchical data layout abstraction.
% Explain ragged, sparse data structures and PETSc integration.
% Present layout algorithm (where I tabulate the offsets).

\end{document}
