\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Mesh-like data layouts}
\label{chapter:mesh_data_layouts}

\pyop3 was created to provide a richer abstraction than \pyop2 for describing stencil-like operations over unstructured meshes.
Most of the innovation in \pyop3 stems from its novel data model.
Data structures associated with a mesh are created using more information about the mesh topology.
This lays the groundwork for a much more expressive DSL since more of the semantics are captured/represented.

\begin{figure}
  \centering
  \includegraphics{two_cell_mesh_lagrange.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{two_cell_mesh_lagrange_nodal.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_nodal}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{two_cell_mesh_lagrange_data_layout_flat.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_flat}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{two_cell_mesh_lagrange_data_layout_flat_nodal.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_flat_nodal}
\end{figure}

\begin{figure}
  \centering
  \includegraphics{two_cell_mesh_lagrange_data_layout_nested.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_nested}
\end{figure}

The semantics for data kept on a mesh are not accurately captured by existing array abstractions.

% TODO does this go here? background?
Classic existing abstractions include N-dimensional array, ragged arrays and struct-of-arrays.

To provide a motivating example, consider the mesh shown in \cref{fig:two_cell_mesh_lagrange}. % P3 quad would look good
Degree 3 Lagrange elements have been used and these have 1 DoF per vertex, 2 per edge and 1 per cell.
DoFs are always stored contiguously per mesh point, and so the data layout for this mesh would look something like that shown in \cref{fig:YYY}.  % data layout of the mesh
It is clear that, due to the variable step size for each mesh point, an N-dimensional array (with N > 1) is a poor fit for describing the layout.
One could also view the data as just a flat array (figure ZZZ), but this loses the information about the mesh points.  % just show a diagram where nodes are indistinguishable
We can therefore conclude that mesh data layouts require a new abstraction for comprehensively describing their semantics: \textit{axis trees}.

\section{Axis trees}

\begin{figure}
  \centering
  %
  \begin{subfigure}{.6\textwidth}
    \centering
    \includegraphics{two_cell_mesh_lagrange_axis_tree.pdf}
    \caption{
      TODO.
      For simplicity the component labels for the \textit{dof} subaxes have been omitted.
    }
    \label{fig:two_cell_mesh_lagrange_axis_tree}
  \end{subfigure}
  %
  \vspace{1em}
  %
  \begin{subfigure}{\textwidth}
    \centering
    \begin{minted}{python}
axes = AxisTree.from_nest({
  Axis({"cell": 2, "vertex": 4, "edge": 5}, "mesh"): [
    Axis(1, "dof"),  # cell DoFs
    Axis(1, "dof"),  # vertex DoFs
    Axis(2, "dof"),  # edge DoFs
  ]
})
    \end{minted}
    \caption{TODO}
    \label{fig:two_cell_mesh_lagrange_code}
  \end{subfigure}
  %
  \caption{
    The axis tree representing the data layout for mesh data corresponding to that shown in \cref{fig:two_cell_mesh_lagrange}.
    Note that the data has not been reordered here (see \cref{sec:renumbering}).
  }
  \label{fig:two_cell_mesh_lagrange_pyop3}
\end{figure}

From \cref{fig:YYY} it can be observed that the data layout naturally decomposes into a tree-like structure.
For every class of topological entity (i.e. vertex, edge or cell) there is a distinct number of DoFs associated with it.

Typically, this structural information is discarded.
\pyop3, however, is capable of capturing this information through using the concept of an \textit{axis tree}.

And axis tree is composed of a hierarchy of \textit{axes}, and each axis has one or more \textit{axis components}.
Each axis may either be the \textit{root} axis, with no parent, or it has a parent consisting of the 2-tuple $(\textrm{parent axis}, \textrm{parent component})$.
In other words each subaxis is attached to a particular axis, component pair like, say, the cells of a mesh.

To uniquely identify axes and components, they are both equipped with a \textit{label}.
With these labels, one can uniquely describe a particular \textit{path} going down the tree from root to leaf.
To give an example from \cref{fig:two_cell_mesh_lagrange_axis_tree}, one could select the DoFs associated with the edges by passing the path (as a mapping): \pycode{{ "mesh": "edge", "dof": None }}.
The keys of the mapping are the axis labels and the values are the component labels.
\pycode{None} is permissible for the \pycode{"dof"} axis because there is only a single component, and hence no ambiguity.
Axis component labels must be unique within an axis, and axis labels must be unique within each possible path leading from root to leaf.

% not sure where this goes.
The notion of an \textit{axis} has already been well established by numpy.
If we consider a 3-dimensional numpy array with shape \pycode{(3, 4, 5)}, each dimension of the array is considered to be an axis.
One can for instance change the order in which the array is traversed by specifying the axes via a \pycode{transpose} call (e.g. \pycode{numpy.transpose(array, (2, 0, 1))}).

\subsection{Examples}

\subsubsection{Vector-valued function spaces}

\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{vector_axis_tree.pdf}
    \caption{TODO}
    \label{fig:vector_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{vector_data_tree.pdf}
    \caption{TODO}
    \label{fig:vector_data_tree}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:vector_axis_data_tree}
\end{figure}

% show tree and dof layout for mesh coordinates (2D) truncated
% can change dof ordering to make vec outer

This approach naturally extends to tensor-valued function spaces, where the multiple inner axes may be provided to represent, for example, a small $3 \times 3$ matrix stored for every mesh point.

\subsubsection{Mixed function spaces}

% show tree and dof layout (truncated) perhaps use a common finite element pair
% Scott-Vogelius FE pair, used for Stokes (see defelement for refs)
\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{mixed_axis_tree.pdf}
    \caption{TODO}
    \label{fig:mixed_axis_tree}
  \end{subfigure}

\end{figure}

% nesting mixed things!

In exactly the same way as for vector-/tensor-valued function spaces, the order in which the axes are declared is flexible...

\section{Renumbering for data locality}
\label{sec:renumbering}

For memory-bound codes, performance is synonymous with data locality.
In the case of stencil codes like finite element assembly, one should aim to arrange the data such that the data required for a single stencil calculation is contiguous in memory and can be read from memory into cache with only a single instruction.

For simulations involving unstructured meshes, data reorderings that provide perfect streaming access to memory are not possible and so renumbering strategies have been developed to try and maximise locality.
For example, the data layout shown in \cref{fig:two_cell_mesh_lagrange_data_layout_flat} approximates the strategy taken by \pyop2, cells are traversed according to some RCM ordering and the cell closures are packed next to the cell~\cite{langeEfficientMeshManagement2016}.
The is effective for finite element codes because finite element assembly (usually) involves iterating over cells and accessing the data in their closures.

In \pyop3, we choose a simple approach and defer to PETSc to provide us with an appropriate RCM numbering for the points.
This is communicated to the axis tree by giving an axis, in this case the \pycode{"mesh"} one, a \pycode{numbering} argument.
This numbering consists of the flat indices of the axis and is exactly the object given to us from PETSc.
This is not quite the case in parallel (see \cref{chapter:parallel}).

\section{Ragged arrays}

% comes after ragged arrays since they impact this
\section{Computing offsets}

\begin{figure}
  \centering
  %
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
    \caption{TODO}
    \label{fig:linear_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
    \caption{TODO}
    \label{fig:linear_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$a$, $b$, $c$\} & $6 i_a + 2 i_b + i_c$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:multi_component_layouts}
  \end{subfigure}
  \caption{TODO}
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the shape of a numpy array decribes how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses an ultimately flat array.
Indeed, in \pyop3 (flat) numpy arrays are used as the underlying data structure.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.

In \pyop3, axis trees are traversed to produce \textit{layout functions}.
These are symbolic expressions of zero or more indices that can be evaluated to give the correct offset into the underlying array.
Layout functions, expressed in the symbolic maths package \textit{pymbolic}\footnote{https://documen.tician.de/pymbolic/index.html}, may either be evaluated given a set of indices or used during code generation.

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a numpy array with shape \pycode{(2, 3, 2)} with the numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $6 i_a + 2 i_b + i_c$.

\subsection{The layout algorithm, step by step}

The algorithm can be deconstructed into two stages:
\begin{enumerate}
  \item
    Determine the right expression for describing the layout of each axis component separately.
    For the linear axis tree shown in \cref{fig:linear_axis_data_tree} this corresponds to determining the expressions $6 i_a$, $2 i_b$ and $i_c$.
  \item
    Add the component-wise layout expressions together.
\end{enumerate}
Of these, the former stage is by far the most complex and is the one that will be explained in more detail below.

In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.

There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsubsection{Linear axis trees}

\begin{algorithm}
  \begin{minted}[linenos]{python}
def tabulate_layouts_linear(axis: Axis):
  layouts = {}

  # post-order traversal
  if has_subaxis(axis): 
    subaxis = get_subaxis(axis)
    layouts |= tabulate_layouts_linear(subaxis)

  # layout expression for this axis
  if has_subaxis(axis):
    step = get_subaxis_size(axis)
  else:
    step = 1
  layouts[axis] = AxisVar(axis) * step

  return layouts
  \end{minted}
  %
  \caption{
    Algorithm for computing the layout functions of a linear (single component) axis tree such as that shown in \cref{fig:linear_axis_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:tabulate_layouts_linear}
\end{algorithm}

We begin our exposition with the simplest possible case: ``linear" axis trees.
A ``linear" tree means that the axes in the tree are restricted to be single component.
Such trees are directly equivalent to numpy-like N-dimensional arrays or \textit{tensor} objects in many domain-specific programming languages.
An example of such a tree and data layout is shown in \cref{fig:linear_axis_data_tree}.

Pseudocode for determining the right layout function for a linear axis tree is shown in \cref{alg:tabulate_layouts_linear}.
The axis tree is traversed in a post-order fashion with subaxes handled first (the reason for this is made clear in \cref{sec:layout_alg_ragged}).
At each axis, since we only require affine expressions, the layout function is simply the symbolic expression \pycode{AxisVar(axis) * step}, where \pycode{AxisVar(axis)} is a pymbolic \pycode{Variable} object and step is an integer corresponding to the size of the subtree as seen from that axis.

\subsubsection{Multi-component axis trees}
\label{sec:layout_alg_multi_component}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree}
    \caption{TODO}
    \label{fig:multi_component_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{multi_component_data_tree}
    \caption{TODO}
    \label{fig:multi_component_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$(a, x)$, $b$\} & $3 i_a + i_b$ \\
      \hline
      \{$(a, y)$, $c$\} & $2 i_a + i_c + 6$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:multi_component_layouts}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:multi_component_axis_tree_all}
\end{figure}

\begin{algorithm}
  \begin{minted}[linenos,highlightlines={5-7,11-12,17-18},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_multi_component(axis: Axis):
  layouts = {}

  # post-order traversal
?\tikzmark{a}?  for component in axis.components:
?\tikzmark{b}?    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      layouts |= tabulate_layouts_multi_component(subaxis)

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  % https://tex.stackexchange.com/questions/287549/is-it-possible-to-use-tikzmark-inside-minted
  \begin{tikzpicture}[remember picture]
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (alabel) at ($(pic cs:a)+(\textwidth+12,.1)$) {A};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (blabel) at ($(pic cs:b)+(\textwidth+12,-.1)$) {B};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (clabel) at ($(pic cs:c)+(\textwidth+12,-.1)$) {C};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (dlabel) at ($(pic cs:d)+(\textwidth+12,-.1)$) {D};

    % alternative with braces, unsure which is better
    % \coordinate (alabelbottom) at ($(pic cs:a)+(\textwidth,-4pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (alabelbottom) -- node [right=10pt] {A} ++ (0,13pt);
    %
    % \coordinate (blabelbottom) at ($(pic cs:b)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (blabelbottom) -- node [right=10pt] {B} ++ (0,25pt);
    %
    % \coordinate (clabelbottom) at ($(pic cs:c)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (clabelbottom) -- node [right=10pt] {C} ++ (0,25pt);
    %
    % \coordinate (dlabelbottom) at ($(pic cs:d)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (dlabelbottom) -- node [right=10pt] {D} ++ (0,25pt);

    \coordinate (alabeltop) at ($(pic cs:a)+(\textwidth,8pt)$);
    \coordinate (alabelbottom) at ($(pic cs:b)+(\textwidth,-16pt)$);
    \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (alabelbottom) -- node [right=10pt] {A} (alabeltop);

    \coordinate (blabeltop) at ($(pic cs:c)+(\textwidth,8pt)$);
    \coordinate (blabelbottom) at ($(pic cs:d)+(\textwidth,-16pt)$);
    \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (blabelbottom) -- node [right=10pt] {B} (blabeltop);
  \end{tikzpicture}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
  }
  \label{alg:tabulate_layouts_multi_component}
\end{algorithm}

When multi-component axis trees are introduced, a number of things change:
First, there are now multiple layout functions per axis.
This is one per \pycode{(axis, component)} pair.
Second, the affine indexing used in the linear case above must now also include offsets.

This is shown in \cref{fig:multi_component_axis_tree_all}.
The root axis of the axis tree now has two components, given the labels $x$ and $y$, each with their own subaxis (labelled $b$ and $c$).
The layouts of the $(a, x)$ part of the tree are effectively unchanged from the linear case, but the $y$ component of axis $a$ now clearly carries an offset.
This is shown in the layout functions in \cref{fig:multi_component_layouts}.

The modifications from \cref{alg:tabulate_layouts_linear} required to determine the right layout function for a multi-component axis tree are relatively straightforward.
The modified algorithm is shown in \cref{alg:tabulate_layouts_multi_component} with the core changes labelled and highlighted in red.
These core changes are:
\begin{itemize}
  \item[\textbf{A}] The post-order traversal must now be over \textit{per-component} subaxes, so a loop over axis components is required.
  \item[\textbf{B}] The layout functions are now stored per \pycode{(axis, component)} pair, and an additional offset, named \pycode{start}, is added.
\end{itemize}

\subsubsection{Ragged axis trees}
\label{sec:layout_alg_ragged}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{ragged_axis_tree}
    \caption{TODO}
    \label{fig:ragged_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{ragged_data_tree}
    \caption{TODO}
    \label{fig:ragged_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    %
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$a$, $b$, $c$\} & $\pycode{[[0, 1], [1, 3]]}_{i_a,i_b} + i_c$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:ragged_layouts}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:ragged_axis_tree_all}
\end{figure}

% TODO: Once things have been cleaned up, redo this.
\begin{algorithm}
  \begin{minted}[linenos,highlightlines={},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_ragged(axis: Axis):
  layouts = {}

  # post-order traversal
  for component in axis.components:
    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      sublayouts, subtree = tabulate_layouts_ragged(subaxis)
      layouts |= sublayouts

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may be ragged.
  }
  \label{alg:tabulate_layouts_ragged}
\end{algorithm}

\section{Data structures}

Thus far we have only discussed the \textit{specification} of how data is stored in \pyop3 and not the actual implementation.
For continuum mechanics problems one typically needs to have representations for scalars, vectors and matrices.
In \pyop3, recycling the terminology from \pyop2, we call scalars \pycode{Globals}, vectors \pycode{Dats} and matrices \pycode{Mats}.
All of these data structures work in parallel, and their parallel implementation is deferred to \cref{chapter:parallel}.

% I reckon that any indexing information should be deferred to the start of the indexing section.

\subsection{Scalars (\pycode{Globals})}

\pycode{Globals} are the simplest of \pyop3's data structures.
They wrap a single scalar value, which may be of any data type (e.g. \pycode{int32}, \pycode{float64}, \pycode{complex128}) and thus have a trivial data layout, hence they have no need for axis trees.
It is not valid to index into a \pycode{Global} (\cref{chapter:indexing}).

\subsection{Vectors (\pycode{Dats})}

Thus far, all of the data structures that we have encountered would be stored as \pycode{Dats}.
\pycode{Dats} are constructed with a single axis tree that provides the information necessary to address the underlying flat array that carries the data.
Having a single axis tree, \pycode{Dats} may be indexed using a single index (\cref{chapter:indexing}).

Currently \pycode{Dats} use numpy arrays as the underlying data storage mechanism, but we intend to permit further array types to enable targeting accelerator architectures like CUDA GPUs.

\subsection{Matrices (\pycode{Mats})}

\pycode{Mats} require 2 axis trees: one for the rows of the matrix and one for the columns.
They rely on PETSc \ccode{Mat} objects for the underlying data storage.
To improve performance one should preallocate the matrix by constructing a \pycode{Sparsity} object and doing a simulated run of all the loop expressions so that non-zeros are put in the right places.

Since \pycode{Mats} have two axis trees, two indices are needed when indexing.

\end{document}
