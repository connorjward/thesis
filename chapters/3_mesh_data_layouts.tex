\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Mesh-like data layouts}
\label{chapter:mesh_data_layouts}

\pyop3 was created to provide a richer abstraction than \pyop2 for describing stencil-like operations over unstructured meshes.
Most of the innovation in \pyop3 stems from its novel data model.
Data structures associated with a mesh are created using more information about the mesh topology.
This lays the groundwork for a much more expressive DSL since more of the semantics are captured/represented.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange_nodal.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_nodal}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange_data_layout_flat.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_flat}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange_data_layout_flat_nodal.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_flat_nodal}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{two_cell_mesh_lagrange_data_layout_nested.pdf}
  \caption{TODO}
  \label{fig:two_cell_mesh_lagrange_data_layout_nested}
\end{figure}

The semantics for data kept on a mesh are not accurately captured by existing array abstractions.

% TODO does this go here? background?
Classic existing abstractions include N-dimensional array, ragged arrays and struct-of-arrays.

To provide a motivating example, consider the mesh shown in \cref{fig:two_cell_mesh_lagrange}. % P3 quad would look good
Degree 3 Lagrange elements have been used and these have 1 DoF per vertex, 2 per edge and 1 per cell.
DoFs are always stored contiguously per mesh point, and so the data layout for this mesh would look something like that shown in \cref{fig:YYY}.  % data layout of the mesh
It is clear that, due to the variable step size for each mesh point, an N-dimensional array (with N > 1) is a poor fit for describing the layout.
One could also view the data as just a flat array (figure ZZZ), but this loses the information about the mesh points.  % just show a diagram where nodes are indistinguishable
We can therefore conclude that mesh data layouts require a new abstraction for comprehensively describing their semantics: \textit{axis trees}.

\section{Axis trees}

\begin{figure}
  \centering
  %
  \begin{subfigure}{.6\textwidth}
    \centering
    \includegraphics[width=\textwidth]{two_cell_mesh_lagrange_axis_tree.pdf}
    \caption{
      TODO.
      For simplicity the component labels for the \textit{dof} subaxes have been omitted.
    }
    \label{fig:two_cell_mesh_lagrange_axis_tree}
  \end{subfigure}
  %
  \vspace{1em}
  %
  \begin{subfigure}{\textwidth}
    \centering
    \begin{minted}{python}
axes = AxisTree.from_nest({
  Axis({"cell": 2, "vertex": 4, "edge": 5}, "mesh"): [
    Axis(1, "dof"),  # cell DoFs
    Axis(1, "dof"),  # vertex DoFs
    Axis(2, "dof"),  # edge DoFs
  ]
})
    \end{minted}
    \caption{TODO}
    \label{fig:two_cell_mesh_lagrange_code}
  \end{subfigure}
  %
  \caption{
    The axis tree representing the data layout for mesh data corresponding to that shown in \cref{fig:two_cell_mesh_lagrange}.
    Note that the data has not been reordered here (see \cref{sec:renumbering}).
  }
  \label{fig:two_cell_mesh_lagrange_pyop3}
\end{figure}

From \cref{fig:YYY} it can be observed that the data layout naturally decomposes into a tree-like structure.
For every class of topological entity (i.e. vertex, edge or cell) there is a distinct number of DoFs associated with it.

Typically, this structural information is discarded.
\pyop3, however, is capable of capturing this information through using the concept of an \textit{axis tree}.

And axis tree is composed of a hierarchy of \textit{axes}, and each axis has one or more \textit{axis components}.
Each axis may either be the \textit{root} axis, with no parent, or it has a parent consisting of the 2-tuple $(\textrm{parent axis}, \textrm{parent component})$.
In other words each subaxis is attached to a particular axis, component pair like, say, the cells of a mesh.

To uniquely identify axes and components, they are both equipped with a \textit{label}.
With these labels, one can uniquely describe a particular \textit{path} going down the tree from root to leaf.
To give an example from \cref{fig:two_cell_mesh_lagrange_axis_tree}, one could select the DoFs associated with the edges by passing the path (as a mapping): \pycode{{ "mesh": "edge", "dof": None }}.
The keys of the mapping are the axis labels and the values are the component labels.
\pycode{None} is permissible for the \pycode{"dof"} axis because there is only a single component, and hence no ambiguity.
Axis component labels must be unique within an axis, and axis labels must be unique within each possible path leading from root to leaf.

% not sure where this goes.
The notion of an \textit{axis} has already been well established by numpy.
If we consider a 3-dimensional numpy array with shape \pycode{(3, 4, 5)}, each dimension of the array is considered to be an axis.
One can for instance change the order in which the array is traversed by specifying the axes via a \pycode{transpose} call (e.g. \pycode{numpy.transpose(array, (2, 0, 1))}).

\subsection{Examples}

\subsubsection{Vector-valued function spaces}

\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{vector_axis_tree.pdf}
    \caption{TODO}
    \label{fig:vector_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{vector_data_tree.pdf}
    \caption{TODO}
    \label{fig:vector_data_tree}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:vector_axis_data_tree}
\end{figure}

% show tree and dof layout for mesh coordinates (2D) truncated
% can change dof ordering to make vec outer

This approach naturally extends to tensor-valued function spaces, where the multiple inner axes may be provided to represent, for example, a small $3 \times 3$ matrix stored for every mesh point.

\subsubsection{Mixed function spaces}

% show tree and dof layout (truncated) perhaps use a common finite element pair
% Scott-Vogelius FE pair, used for Stokes (see defelement for refs)
\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{mixed_axis_tree.pdf}
    \caption{TODO}
    \label{fig:mixed_axis_tree}
  \end{subfigure}

\end{figure}

% nesting mixed things!

In exactly the same way as for vector-/tensor-valued function spaces, the order in which the axes are declared is flexible...

\section{Renumbering for data locality}
\label{sec:renumbering}

For memory-bound codes, performance is synonymous with data locality.
In the case of stencil codes like finite element assembly, one should aim to arrange the data such that the data required for a single stencil calculation is contiguous in memory and can be read from memory into cache with only a single instruction.

For simulations involving unstructured meshes, data reorderings that provide perfect streaming access to memory are not possible and so renumbering strategies have been developed to try and maximise locality.
For example, the data layout shown in \cref{fig:two_cell_mesh_lagrange_data_layout_flat} approximates the strategy taken by \pyop2, cells are traversed according to some RCM ordering and the cell closures are packed next to the cell~\cite{langeEfficientMeshManagement2016}.
The is effective for finite element codes because finite element assembly (usually) involves iterating over cells and accessing the data in their closures.

In \pyop3, we choose a simple approach and defer to PETSc to provide us with an appropriate RCM numbering for the points.
This is communicated to the axis tree by giving an axis, in this case the \pycode{"mesh"} one, a \pycode{numbering} argument.
This numbering consists of the flat indices of the axis and is exactly the object given to us from PETSc.
This is not quite the case in parallel (see \cref{chapter:parallel}).

\section{Data structures}
\label{sec:data_structures}

\subsection{Vectors (\pycode{Dats})}

\subsection{Matrices (\pycode{Mats})}

\section{Ragged arrays}

% comes after dats because implemented with one!

% comes after ragged arrays since they impact this
\section{Computing offsets}

\begin{figure}
  \centering
  %
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
    \caption{TODO}
    \label{fig:linear_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
    \caption{TODO}
    \label{fig:linear_data_tree}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the shape of a numpy array decribes how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses an ultimately flat array.
Indeed, in \pyop3 (flat) numpy arrays are used as the underlying data structure.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.

In \pyop3, axis trees are traversed to produce \textit{layout functions}.
These are symbolic expressions of zero or more indices that can be evaluated to give the correct offset into the underlying array.
Layout functions, expressed in the symbolic maths package \textit{pymbolic}\footnote{https://documen.tician.de/pymbolic/index.html}, may either be evaluated given a set of indices or used during code generation.

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a numpy array with shape \pycode{(2, 3, 2)} with the numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $6 i_a + 2 i_b + i_c$.

\subsection{The layout algorithm, step by step}

% not a useful thing to write really
In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.
There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsubsection{Linear axis trees}

\begin{algorithm}
  \begin{minted}[linenos]{python}
def tabulate_layouts_linear(axis: Axis):
  layouts = {}

  # pre-order traversal
  if has_subaxis(axis): 
    subaxis = get_subaxis(axis)
    layouts |= tabulate_layouts_linear(subaxis)

  # layout expression for this axis
  if has_subaxis(axis):
    step = get_subaxis_size(axis)
  else:
    step = 1
  layouts[axis] = AxisVar(axis) * step

  return layouts
  \end{minted}
  %
  \caption{
    Algorithm for computing the layout functions of a linear (single component) axis tree such as that shown in \cref{fig:linear_axis_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:tabulate_layouts_linear}
\end{algorithm}

\subsubsection{Multi-component axis trees}

\begin{algorithm}
  \begin{minted}[linenos,highlightlines={4,6-7,11-12,17-18},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_multi_component(axis: Axis):
  layouts = {}

?\tikzmark{a}?  for component in axis.components:
    # pre-order traversal
?\tikzmark{b}?    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      layouts |= tabulate_layouts_multi_component(subaxis)

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  % https://tex.stackexchange.com/questions/287549/is-it-possible-to-use-tikzmark-inside-minted
  \begin{tikzpicture}[remember picture]
    \node [circle,overlay,fill=white,draw=black,minimum width=18pt] (alabel) at ($(pic cs:a)+(\textwidth+16,.1)$) {A};
    \node [circle,overlay,fill=white,draw=black,minimum width=18pt] (blabel) at ($(pic cs:b)+(\textwidth+16,-.1)$) {B};
    \node [circle,overlay,fill=white,draw=black,minimum width=18pt] (clabel) at ($(pic cs:c)+(\textwidth+16,-.1)$) {C};
    \node [circle,overlay,fill=white,draw=black,minimum width=18pt] (dlabel) at ($(pic cs:d)+(\textwidth+16,-.1)$) {D};

    % alternative with braces, unsure which is better
    % \coordinate (alabelbottom) at ($(pic cs:a)+(\textwidth,-4pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (alabelbottom) -- node [right=10pt] {A} ++ (0,13pt);
    %
    % \coordinate (blabelbottom) at ($(pic cs:b)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (blabelbottom) -- node [right=10pt] {B} ++ (0,25pt);
    %
    % \coordinate (clabelbottom) at ($(pic cs:c)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (clabelbottom) -- node [right=10pt] {C} ++ (0,25pt);
    %
    % \coordinate (dlabelbottom) at ($(pic cs:d)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (dlabelbottom) -- node [right=10pt] {D} ++ (0,25pt);
  \end{tikzpicture}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
    None of the axes may be renumbered.
  }
  \label{alg:tabulate_layouts_linear}
\end{algorithm}

\subsubsection{Renumbered axis trees}

\subsubsection{Ragged axis trees}

\end{document}

% ====================OLD=======================
% \subsubsection{Representing data layouts with DMPlex}
%
% DMPlex represents a mesh as a set of points where the points are divided into \textit{strata} (cells, edges, vertices, etc).
% These points are connected in a graph (Hasse diagram) and a rich set of queries can be used to determine the right adjacencies needed for things like the finite element method.
%
% In order to associated data with these mesh points, a typical PETSc application will construct a PETSc \ccode{Section}.
% These are simple CSR-like (?) data structures that encode a data layout by associating a particular number of DoFs with each mesh point.
% Sections are a powerful tool for describing data layouts but they have a number of limitations:
%
% \begin{itemize}
%   \item
%     Sections are fully ragged.
%     They only store DoF information per point in a completely unstructured way and are incapable of knowing, say, that every cell in the mesh stores exactly one DoF.
%     This can prohibit the compiler from making certain optimisations (e.g. loop unrolling) that it would have been able to do were it to know of a constant loop extent.
%     Additionally, this variable size increases memory pressure as redundant arrays of constant sizes need to be streamed through memory.
%
%   \item
%     DoFs per point are treated as a flat array.
%     This means that shape information is lost for, say, vector-valued functions.
% \end{itemize}
%
% With PETSc/DMPlex, the P3 DoF layout would be represented as shown in Figure~\ref{???}.
% % figure showing PetscSection info
%
% \subsubsection{Data layouts in \pyop2}
%
% \pyop2 takes a very different approach to describing data layouts to DMPlex.
% Firstly, it has no conception of what a mesh is and it deals solely with \textit{sets} and \textit{mappings between sets}.
% The rich query language provided by DMPlex is therefore unavailable and the task of determining the right adjacency maps is passed to the user.
%
% \subsection{What \pyop3 does}

  % start with P3?


% Introduce hierarchical data layout abstraction.
% Explain ragged, sparse data structures and PETSc integration.
% Present layout algorithm (where I tabulate the offsets).

