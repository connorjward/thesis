\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Indexing}
\label{chapter:indexing}

Just like \numpy, data structures in \pyop3 can be indexed.
Compared with \numpy where indexing is accomplished with a list of index-like objects, one for each axis (\cref{sec:numpy_indexing_arrays}), \pyop3 needs a more complicated solution to accomodate for the fact that data structures are now tree-like.
Instead of lists of indices, \pyop3 instead uses \emph{index trees}.

\section{Index trees}
\label{sec:index_trees}

\begin{algorithm}
  \caption{
    Algorithm that indexes an axis tree using an index tree.
    The function is initially called passing the root of the index tree.
  }

  \begin{pyalg2}
    def index_axes(index: Index, input_axis_tree: AxisTree):
      # process the current index
      axis_tree, index_info = index_handler(index, input_axis_tree)

      # recursively visit child indices
      for component in index.components:
        if has_subindex(index, component):
          subindex = get_subindex(index, component)
          subaxis_tree, subindex_info = index_axes(subindex, input_axis_tree)

          axis_tree.add_subtree(subaxis_tree)
          index_info.update(subindex_info)

      return axis_tree, index_info
  \end{pyalg2}

  \label{alg:index_axis_tree}
\end{algorithm}

In the same way that axis trees are built from labelled axis objects and axis components, index trees are built from labelled \emph{index} objects and \emph{index components}.
However, whereas axis and axis components encode the dimensions of an array, indices in index trees instead encode \emph{axis transformations} of the form

\begin{equation}
  \textnormal{axis} \quad \circ \quad \textnormal{index} \quad \to \quad (\textnormal{axis tree},\ \textnormal{index information}).
  \label{eq:index_transform}
\end{equation}

\noindent
That is, each index takes an input axis and transforms it, returning a new axis tree alongside additional information encoding the relation between the old and new axes.

This process may then be extended to indexing an entire axis tree, giving the transformation

\begin{equation*}
  \textnormal{axis tree} \quad \circ \quad \textnormal{index tree} \quad \to \quad (\textnormal{axis tree},\ \textnormal{index information}),
\end{equation*}

\noindent
this time returning a new axis tree and aggregated index information from each of the indices.

Code for this operation is shown in \cref{alg:index_axis_tree}.
The index tree is traversed and the function \pycode{index_handler()}, representing the transformation in \cref{eq:index_transform}, is called on each index, with the resulting axis tree and index information aggregated together and returned.

\subsubsection{Index information}

In addition to having a new axis tree with new sizes and labels, for indexing to work \pyop3 needs to know how the new and old axis trees relate.
In particular, it needs to be able to take multi-indices given for the new axis tree (the \emph{source}) and map them to multi-indices for the old tree (the \emph{target}).
Represented by the `index information' shown above, the multi-index relations are represented by two mappings:

\begin{description}
  \item[Target paths] A map connecting labels of the source tree with labels of the target.
  \item[Target expressions] A map connecting index expressions of the source tree with those of the target.
\end{description}

With these, \pyop3 has sufficient information to:
(1) select the right \emph{layout function} from the target axis tree, and
(2) substitute index expressions into the layout function, resulting in a \emph{substituted layout function} that accepts multi-indices of the source axis tree instead of the target.
This approach allows \pyop3 to represent indexing operations symbolically as \emph{views}, regardless of the indexing operation applied.
This contrasts with \numpy where only `simple' indexing operations are supported without copying the array.

\begin{example}{Linear index trees}

\begin{figure}
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # index the array
      indexed_dat = dat[::2, 1::]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_linear_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout.pdf}
    \caption{
      The axis tree transformation.
    }
    \label{fig:index_linear_transform}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
  \label{fig:index_linear}
\end{figure}

To illustrate this with a simple example, consider the indexing operation shown in \cref{fig:index_linear_tree_all}.
It shows a slicing operation applied to a linear axis tree with shape \pycode{(5, 3)} and axes labelled $a$ and $b$.
The index tree is also linear and consists of two \textit{slice} objects over the axes $a$ and $b$ respectively with the former taking every other entry in $a$ (\pycode{[::2]}) and the latter taking all but the first entry in $b$ (\pycode{[1::]}).
The indexed axis tree resulting from the composition of these trees is shown to the right: only the selected indices from axes $a$ and $b$ are present and the axes have been relabelled (arbitrarily) $c$ and $d$.

% \noindent
% To give an example, \pyop3 represents slices as \pycode{Slice} index objects with \pycode{AffineSliceComponent} index components.
% Each \pycode{Slice} object has a \emph{target axis}, the label of the axis getting sliced, and each \pycode{AffineSliceComponent} has a \emph{target component}, the label of the axis component getting sliced.
% Having more than one \pycode{AffineSliceComponent} is supported to allow for slicing of different axis components.
%
% As well as a target component label, \pycode{AffineSliceComponents} also store \pycode{start}, \pycode{stop}, and \pycode{step} attributes, just like a normal Python \pycode{slice} object.
% \pycode{Subsets} are also represented as a slice component, storing an integer array instead of \pycode{start}, \pycode{stop}, \pycode{step} values.
%
% Graphically, one can represent slices like
%
% \begin{center}
%   \includegraphics{demo_slice.pdf}
% \end{center}
%
% \noindent
% indicating, in this case, a slice of axis $a$ using subset \pycode{[0,2]} for component $x$ and affine slice \pycode{[1::]} for component $y$.

  % target path
    % It allows \pyop3 to know where the source axes came from so it can select the right layout functions (\cref{sec:layouts}) from the target tree.
    % In \cref{fig:index_linear_tree_exprs}, the target path shows that source axes $c$ and $d$ map back to $a$ and $b$ in the original array.

  % target exprs.
    % In \cref{fig:index_linear_tree_exprs} the two target expressions are shown to be $i_a = 2 i_c$ and $i_b = i_d + 1$, telling us that $c_m$ maps to $a_{2m}$ and that $d_n$ maps to $b_{n+1}$ respectively.


\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{ c,\ d \}$ & $\{a,\ b\}$ & $\{i_a = 2 i_c,\ i_b = i_d+1\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
    \hline[1pt]
    $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c, i_d) = 6 i_c + i_d + 1$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\end{example}

\begin{example}{Multi-component index trees}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis({"x": 3, "y": 2}, "a")
      axis_b = Axis(2, "b")
      axis_c = Axis(3, "c")
      axes = AxisTree.from_nest({axis_a: [axis_b, axis_c]})
      dat = Dat(axes)

      # create the index tree
      index_a = Slice("a", [Subset("x", [0, 2]),
                            AffineSliceComponent("y", start=1)])
      index_b = ScalarIndex("b", 1)
      index_c = Slice("c", [Subset([1, 2])])
      index_tree = IndexTree.from_nest({index_a: [index_b, index_c]})

      # index the array
      indexed_dat = dat[index_tree]
    \end{pyalg2}

    \caption{\pyop3 code that indexes a multi-component array with an index tree.}
    \label{fig:multi_component_slice_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[scale=.9]{multi_component_slice_transform.pdf}
    \caption{
      Diagram of the data layout transformation.
      ...
    }
    \label{fig:multi_component_slice_transform_flowchart}
  \end{subfigure}

  \caption{
    TODO
  }
  \label{fig:multi_component_slice}
\end{figure}

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{d^t\}$ & $\{a^x,\ b\}$ & $\{i_a = \pycode{[0,2][?$i_d$?]},\ i_b = 1\}$ \\
    \hline
    $\{d^u,\ e\}$ & $\{a^y,\ c\}$ & $\{i_a = i_d + 1,\ i_c = \pycode{[1,2][?$i_e$?]}\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
    \hline[1pt]
    $\{a^x,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 2 i_a + i_b$ & $\textnormal{offset}(i_d) = 2 ( \pycode{[0,2][?$i_d$?]} ) + 1$ \\
    \hline
    $\{a^y,\ c\}$ & $\textnormal{offset}(i_a, i_c) = 3 i_a + i_c + 6$ & $\textnormal{offset}(i_d, i_e) = 3(i_d+1) + \pycode{[1,2][?$i_e$?]} + 6$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\end{example}

With these two pieces of information, it is now possible to implement view-like semantics for indexed axis trees.
One simply has to:

\begin{enumerate}
  \item
    Use the target path to select the appropriate layout function from the target axis tree.
  \item
    Modify the layout function by substituting the target indices in the function with the source indices as described by the target expressions attribute of the indexed tree.
  \item
    Evaluate the offset using the new layout function (that is now a function of the source indices rather than the target indices).
\end{enumerate}

% example 1 - now shown in the table...
Applying these steps using the indexing operation of \cref{fig:index_linear_tree_all}, we have:

\begin{enumerate}
  \item
    % TODO: Provide more detail about source paths and how this is retrieved.
    The target paths are $\{c \to a,\ d \to b\}$, so the selected layout function is
    \begin{equation*}
      \textnormal{offset}(i_a, i_b) = 3 i_a + i_b.
    \end{equation*}
  \item
    Substituting the target expressions in \cref{fig:index_linear_tree_exprs}, we get the new layout function
    \begin{equation*}
      \textnormal{offset}(i_c, i_d) = 6 i_c + i_d + 1.
    \end{equation*}
  \item
    The original axis tree may now be addressed using the source indices $i_c$ and $i_d$.
\end{enumerate}

% describe something about subsets for the second example.

\subsection{Index composition}
\label{sec:index_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # use indexed_dat from ?\cref{fig:index_linear}?
      indexed_dat = ...

      # index the array again
      indexed_dat2 = indexed_dat[1::, 1]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_transform.pdf}
    \caption{
      TODO
    }
    \label{fig:index_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Int. path} & \textbf{Int. expressions} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{e\}$ & $\{ c,\ d \}$ & $\{ i_c = i_e + 1,\ i_d = 1 \}$ & $\{a,\ b\}$ & $\{i_a = 2 (i_e+1),\ i_b = 2\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{TODO}
    \label{fig:index_composition_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c) = 6 (i_e+1) + 2$ \\
      \hline[1pt]
    \end{tblr}
    \caption{TODO}
    \label{fig:index_composition_subst_layout}
  \end{subfigure}

  \caption{
    The composition of an already indexed axis tree (from \cref{fig:index_linear_tree_all}) with another index tree.
    Since a scalar index is used, the axis tree ``loses shape" and is transformed from one with shape (3, 2) to one with shape (2,).
    The resulting axis tree can still be mapped correctly back to the original unindexed axis tree.
  }
  \label{fig:index_composition_linear_tree_all}
\end{figure}

Since indexing an axis tree gives back another (indexed) axis tree, it is possible to index the newly created tree using the same code as before.
Index composition is useful in cases where one wants to handle array views in the same way that one might handle unindexed arrays.
This could occur, for instance, if one were to index a vector-valued array to give a view of the array as though it were scalar-valued.
Since the axis trees of both the vector-valued view and the scalar-valued array are identical they may be treated the same way by \pyop3.

An example composition operation is shown in \cref{fig:index_composition}.
The indexed array from \cref{fig:index_linear} is used as input and the array is further sliced.

% how does it differ from the others? intermediate paths and expressions


\section{Indexing with outer loops}
\label{sec:outer_loops}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

% unlike with slices, the indexed object is parametrised by the loop index, does not make sense in another scope

% outer loops are important for packing code (see ch. 1)
% the packed object has some dependence on the outer index

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% the simplest case is that of a loop index (like c_i in intro).
% give an example.

\begin{figure}[h]
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # create the "outer" loop index
      p = axis_a.index()

      # index the array
      indexed_dat = dat[p, :]
    \end{pyalg2}

    \caption{TODO}
    \label{fig:loop_index_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{loop_index_linear_tree_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis is no longer present in the final axis tree as it has been fully indexed.
    }
    \label{fig:loop_index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      \{$b$\} & $\{a,\ b\}$ & $\{i_a = L^p_a,\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the target expression for axis $a$ is the \textit{loop index} $L^p_a$.
      This means that the indexed axis tree cannot be interpreted without the outer loop $p$ being present.
    }
    \label{fig:loop_index_linear_tree_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b) = 3 L^p_a + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_linear_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation equivalent to indexing a \numpy array with shape \pycode{(5, 3)} with indices \pycode{[p, ::]}, where \pycode{p} is an index coming from some outer loop.
    The resulting array has shape \pycode{(3,)} because the outermost loop has been fully indexed by \pycode{p}.
  }
  \label{fig:loop_index_linear_tree_data_layout_all}
\end{figure}

\subsection{Maps}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      ...
      axes = AxisTree.from_iterable(...)
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 code that indexes an array with a map.}
    \label{fig:map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis has been replaced by the map axis $c$.
    }
    \label{fig:index_map_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Using a map means that the index for axis $a$ is an expression containing both the outer loop index ($L^p_a$) and an index over the shape coming from the map's arity ($i_c$).
    }
    \label{fig:index_map_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b, i_c) = 3 f(L^p_a, i_c) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation representing the packing of an axis tree with shape \pycode{(5, 3)} containing the entries referenced by the map $f(p)$, where $p$ is some outer loop index.
    The map has arity 3, so the resulting array has shape \pycode{(3, 3)}.
  }
  \label{fig:index_map}
\end{figure}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

% explain what arity is, it leads to extra shape!
% they need outer loop indices
% expressions are of the form f(i, j), could be an affine transformation or a lookup

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      dat = Dat(Axis(4, "a"))

      # create the "outer" loop and loop index
      axis_x = Axis(3, "x")
      p = axis_x.index()

      # create a ragged map mapping from "x" to "a"
      arity_dat = Dat(axis_x, data=[2, 0, 1])
      f = Map({"x": [MapComponent("a", arity=arity_dat, ...)]})

      # index the array
      indexed_dat = dat[f(p)]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_ragged_map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_ragged_map_transform.pdf}
    \caption{Axis tree transformation.}
    \label{fig:index_ragged_map_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{b\}$ & $\{a\}$ & $\{i_a = f(L^p_a, i_b)\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a\}$ & $\textnormal{offset}(i_a) = i_a$ & $\textnormal{offset}(i_b) = f(L^p_a, i_b)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_subst_layouts}
  \end{subfigure}

  \caption{
    Example indexing an array with a ragged map.
    The resulting array has variable size depending on the value of the loop index $L^p_a$.
  }
  \label{fig:index_ragged_map}
\end{figure}

There are occasions where maps have variable arity, for example the map mapping from vertices in a mesh to its supported edges ($\support(v)$).
In \pyop3 it is straightforward to create maps with a variable arity by providing an array for the arity instead of an integer.
This is demonstrated in \cref{fig:index_ragged_map}.

\subsubsection{Map composition}
\label{sec:indexing_map_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axes = AxisTree.from_iterable([Axis(5, "a"), Axis(3, "b")])
      dat = Dat(axes)

      # create the "outer" loop and loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # create map f, mapping "x" to "y"
      f = Map({"x": [MapComponent("y", arity=3, ...)]})

      # create map g, mapping "y" to "a"
      g = Map({"y": [MapComponent("a", arity=2, ...)]})

      # index the array
      indexed_dat = dat[g(f(p)), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_composition_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_composition_transform.pdf}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ d,\ b\}$ & $\{a,\ b\}$ & $\{i_a = g(f(L^p_a, i_c), i_d),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c, i_d, i_b) = 3 g(f(L^p_a, i_c), i_d) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_subst_layout}
  \end{subfigure}

  \caption{TODO}
  \label{fig:index_map_composition}
\end{figure}

As described in \cref{sec:foundations_dmplex}, it is occasionally desirable to compose maps such that the output of one feeds directly into another.
This is natural to express in \pyop3 (\cref{fig:index_map_composition}).
Note that, since $f$ and $g$ each have an associated arity, the resulting array gains two additional axes.

\section{Data layout transformations}
\label{sec:indexing_data_layout_transformations}

% It is worthwhile to note that the input axis tree (\pycode{old_axis_tree}) is passed into the function but not really used to construct the new tree... (ref alg:index_axis_tree)

\begin{figure}
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_b, axis_a])
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_swap_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_swap_transform.pdf}
    \caption{TODO}
    \label{fig:index_map_swap_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 5 i_b + i_a$ & $\textnormal{offset}(i_b, i_c) = 5 i_b + f(L^p_a, i_c)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_ subst_layout}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
\end{figure}

% when we index things at some point we must know the arrangement of the DoFs (when we pass to local kernel).

The way that index trees prescribe the layout of the indexed axis tree means that one can compute with alternative data layouts (\cref{sec:axis_tree_alternative_layouts}) without needing to make any changes to the indexing code at all.

This is demonstrated in \cref{fig:index_map_swap} which performs the same packing operation as \cref{fig:index_map} but with the axes $a$ and $b$ swapped around.
Observe that the resulting array (\cref{fig:index_map_swap_transform}) and indexing information (\cref{fig:index_map_swap_axis_info}) are identical to that for \cref{fig:index_linear_axis_info}, but that the final layout function differs from the unswapped version: $\textnormal{offset}() = ???$ instead of $\textnormal{offset}() = ???$.

% but need to be explicit about the labels - order matters

\end{document}
