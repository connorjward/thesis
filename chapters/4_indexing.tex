\documentclass[thesis]{subfiles}

\begin{document}

% TODO: Somewhere talk about ragged temporaries?

\chapter{Indexing}

Axis trees provide us with a method for describing the data layout of global objects.
In order to be able to execute compact stencils this is insufficient.
We need a way to extract portions of the array such that they may be operated on independently.
In \pyop3, this extraction operation is referred to as \textit{indexing}.

\section{Fundamentals}

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout}
    \caption{TODO}
    \label{fig:index_linear_tree_data_layout}
  \end{subfigure}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{c|c|c}
      \textbf{Source path} & \textbf{Target path} & \textbf{Index expression} \\
      \hline
      \{$x$, $y$\} & \{$a$, $b$\} & \{$a$: \pycode{2*ix}, $b$: \pycode{iy+1}\} \\
    \end{tabular}
    \caption{TODO}
    \label{fig:index_linear_tree_exprs}
  \end{subfigure}

  \caption{TODO}
  \label{fig:index_linear_tree_all}
\end{figure}

To begin with, consider indexing a linear array with shape \pycode{(10, 3)} (a matrix with 10 rows and 3 columns) with the slice \pycode{[::2, 1:]}.
This is Python syntax for requesting access to every other row of the first axis, and all but the first entry of the second axis.
If this code were to be executed using a numpy array of those dimensions, a new array would be returned with shape \pycode{(5, 2)} containing only those elements.
numpy is capable of reasoning about slices and so this new array would merely be a \textit{view} of the same data; modifying the returned array would also modify the data in the original array.

\pyop3 takes inspiration from numpy to provide similar indexing routines for its arrays, though with support for many more indexing operations.
Since \pyop3 uses code generation, any indexing transformations are necessarily lazy and symbolic, allowing for their insertion into the generated code.

We will use the numpy operation above as an initial example.
An equivalent axis tree can be created... (needs diagram)



\section{Index composition}






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% basic intro
Begin by giving an example of indexing a linear axis tree (10, 3)[::2, 1:] (and explain this terminology).
Explain/show that the axis tree needs to necessarily shrink but the expressions needed to index it go from a*3+b to (2*x)*3+(y+1).
Show the (relabelled) axis tree to demonstrate shrinkage.

Describe the process of indexing an array or axis tree: parse index tree, traverse index tree and generate new axes and collect index expressions, produce a new set of axes with the same layout as before but new axes and index expressions.
(note that both axis trees and arrays are indexable, since we can loop over slices of axes)
Demonstrate this using the same example as above.
Use the ASCII view of the trees to demonstrate?
Note that when we index we keep the layouts and index expressions separate, see index composition section for the reason.

% maybe slightly higher up
Explain why we need to use index *trees* here: to build a wider variety of axes.
If we want to build a new tree like set of axes (e.g. for closure packing) then we need to be able to pack different axis components together.

\section{Loops}

% needs to be discussed here because maps dont make sense otherwise, can talk about how
% we just wrap index exprs in loop index vars so they can be differentiated.

A loop index is constructed by doing axis[???].index().
This loop index can then be used inside an index tree like a slice or map.

A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

Perhaps provide a motivating example where we have array[p, :], or something, show that the layout expression contains p and hence we can substitute in an iname or index value.

\section{Maps}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

Give closure as an example. Index tree.

\subsection{Ragged maps}

Ragged maps are also supported. e.g. support, star

\subsection{Map composition}

e.g. g(f(p))

\section{Index composition}

i.e. indexing an indexed thing

%Give an example indexing Axis(10, "a")[::2][1:].
%The required subst layout targets [2, 4, 6, 8], which is 2*(i+1), not (2*i)+1

cannot directly insert as it breaks composition, need to store index\_exprs separately

\end{document}
