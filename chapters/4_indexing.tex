\documentclass[thesis]{subfiles}

\begin{document}

% TODO: Somewhere talk about ragged temporaries?

\chapter{Indexing}

Axis trees provide us with a method for describing the data layout of global objects.
In order to be able to execute compact stencils this is insufficient.
We need a way to extract portions of the array such that they may be operated on independently.
In \pyop3, this extraction operation is referred to as \textit{indexing}.

\section{Fundamentals}

\todo{Increase table spacing}
\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout}
    \caption{
      Diagram of the data layout transformation.
      The original axis tree (left) is composed with an index tree (see \cref{sec:index_trees}) (middle) to produce a new axis tree (right).
      The bracketed values in the resultant tree show the original indices that they map to.
    }
    \label{fig:index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{c|c|c}
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $d$\} & \{$a$, $b$\} & \{$a$: $2 i_c$, $b$: $i_d+1$\} \\
    \end{tabular}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:index_linear_tree_exprs}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape $(5, 3)$ with the slices (\pycode{::2}) and (\pycode{1::}) on axes $a$ and $b$ respectively.
    The resulting axis tree has shape $(3, 2)$ and different labels: $c$ and $d$.
  }
  \label{fig:index_linear_tree_all}
\end{figure}

To begin with, consider indexing a linear array with shape \pycode{(10, 3)} (a matrix with 10 rows and 3 columns) with the slice \pycode{[::2, 1:]}.
This is Python syntax for requesting access to every other row of the first axis, and all but the first entry of the second axis.
If this code were to be executed using a numpy array of those dimensions, a new array would be returned with shape \pycode{(5, 2)} containing only those elements.
numpy is capable of reasoning about slices and so this new array would merely be a \textit{view} of the same data; modifying the returned array would also modify the data in the original array.

\pyop3 takes inspiration from numpy to provide similar indexing routines for its arrays, though with support for many more indexing operations.
Since \pyop3 uses code generation, any indexing transformations are necessarily lazy and symbolic, allowing for their insertion into the generated code.

We will use the numpy operation above as an initial example.
An equivalent axis tree can be created... (needs diagram)

% source and target axes (transformation)
% index_exprs, target_path
% compose with layout functions to get the right offset

% subsets are also supported in the same way, they can be used to reorder inside axes (give example)

\subsection{Index trees}
\label{sec:index_trees}

% Describe the process of indexing an array or axis tree: parse index tree, traverse index tree and generate new axes and collect index expressions, produce a new set of axes with the same layout as before but new axes and index expressions.
%Explain why we need to use index *trees* here: to build a wider variety of axes.
%If we want to build a new tree like set of axes (e.g. for closure packing) then we need to be able to pack different axis components together.


\subsubsection{Data layout transformations}

% treating index trees like axis-trees-in-waiting means we can specify the data layout of the packed object.
% give an example

\subsection{Index composition}
\label{sec:index_composition}

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_linear_tree_data_layout}
    \caption{TODO}
    \label{fig:index_composition_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{c|c|c}
      \textbf{Source path} & \textbf{Target path} & \textbf{Index expression} \\
      \hline
      \{$e$, $d$\} & \{$a$, $b$\} & \{$a$: $2 (i_e+1)$, $b$: $i_d+1$\} \\
    \end{tabular}
    \caption{TODO}
    \label{fig:index_composition_linear_tree_exprs}
  \end{subfigure}

  \caption{TODO}
  \label{fig:index_composition_linear_tree_all}
\end{figure}

\section{Loop expressions}

\begin{figure}[h]
  \centering
  %
  \begin{subfigure}{.48\textwidth}
    \centering
    \begin{minted}{python}
loop(
  i := dat.axes.index(),
  dat[i].assign(666, eager=False),
)
    \end{minted}
    \caption{TODO}
    \label{fig:simple_loop_pyop3}
  \end{subfigure}
  %
  \begin{subfigure}{.48\textwidth}
    \centering
    \begin{minted}{python}
for i in range(len(numpy_dat)):
  numpy_dat[i] = 666
    \end{minted}
    \caption{TODO}
    \label{fig:simple_loop_python}
  \end{subfigure}

  \caption{TODO}
  \label{fig:simple_loop}
\end{figure}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

In \pyop3, these outer loops are described by the \pycode{loop(...)} construct.
Calling \pycode{loop} creates a \textit{loop expression}, which is a symbolic object representing the loop to be performed.
The loop expression expects a \textit{loop index}, and a collection of \textit{statements}.
The loop index represents the domain to be iterated over and it has an associated axis tree where each element of the axis tree will be visited.
The statements may be further loops or arbitrary operations (see \cref{ch:dsl} for a more in-depth description).

To give an example, one of the simplest possible loops that one can write in \pyop3 is shown in \cref{fig:simple_loop_pyop3}.
Here the loop index (\pycode{i}) is simply ``all elements of \pycode{dat}`` and there is a single statement that sets each entry in \pycode{dat} to the arbitrary value of 666.
Note that the syntax of the loop expression is deliberately similar to that of Python (or other imperative programming languages).

% does this mean that we should introduce dats before this? probably
The challenge here is how to represent the indexing operation \pycode{dat[i]}...

% scalar shape

Furthermore, the indexed object is dependent upon the loop index: the target expressions of the axis tree must reference the loop index.
In \pyop3 we say that it is \textit{context-dependent}.

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% subsection on context-sensitivity?

\section{Maps}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

Give closure as an example. Index tree.

\subsection{Ragged maps}

Ragged maps are also supported. e.g. support, star

\subsection{Map composition}

e.g. g(f(p))

\end{document}
