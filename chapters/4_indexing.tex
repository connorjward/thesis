\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Indexing}
\label{chapter:indexing}

\todo[inline]{It seems a bit clunky to have "example" sections only at the start when the whole chapter is built from examples.}

Just like \numpy, data structures in \pyop3 can be indexed.
Compared with \numpy where indexing is accomplished with a list of index-like objects, one for each axis (\cref{sec:numpy_indexing_arrays}), \pyop3 needs a more complicated solution to accomodate for the fact that data structures are now tree-like.
Instead of lists of indices, \pyop3 instead uses \emph{index trees}.

\section{Index trees}
\label{sec:index_trees}

\begin{algorithm}
  \caption{
    Algorithm that indexes an axis tree using an index tree.
    The function is initially called passing the root of the index tree.
  }

  \begin{pyalg2}
    def index_axes(index: Index, input_axis_tree: AxisTree):
      # process the current index
      axis_tree, index_info = index_handler(index, input_axis_tree)

      # recursively visit child indices
      for component in index.components:
        if has_subindex(index, component):
          subindex = get_subindex(index, component)
          subaxis_tree, subindex_info = index_axes(subindex, input_axis_tree)

          axis_tree.add_subtree(subaxis_tree)
          index_info.update(subindex_info)

      return axis_tree, index_info
  \end{pyalg2}

  \label{alg:index_axis_tree}
\end{algorithm}

In the same way that axis trees are built from labelled axis objects and axis components, index trees are built from labelled \emph{index} objects and \emph{index components}.
However, whereas axis and axis components encode the dimensions of an array, indices in index trees instead encode \emph{axis transformations} of the form

\begin{equation}
  \textnormal{axis} \quad \circ \quad \textnormal{index} \quad \to \quad (\textnormal{axis tree},\ \textnormal{index information}).
  \label{eq:index_transform}
\end{equation}

\noindent
That is, each index takes an input axis and transforms it, returning a new axis tree alongside additional information encoding the relation between the old and new axes.

This process may then be extended to indexing an entire axis tree, giving the transformation

\begin{equation*}
  \textnormal{axis tree} \quad \circ \quad \textnormal{index tree} \quad \to \quad (\textnormal{axis tree},\ \textnormal{index information}),
\end{equation*}

\noindent
this time returning a new axis tree and aggregated index information from each of the indices.

Code for this operation is shown in \cref{alg:index_axis_tree}.
The index tree is traversed and the function \pycode{index_handler()}, representing the transformation in \cref{eq:index_transform}, is called on each index, with the resulting axis tree and index information aggregated together and returned.

\subsubsection{Mapping from indexed to unindexed axis trees}

In addition to having a new axis tree with new sizes and labels, for indexing to work \pyop3 needs to know how the new and old axis trees relate.
In particular, it needs to be able to take multi-indices given for the new axis tree (the \emph{source}) and map them to multi-indices for the old tree (the \emph{target}).
Represented by the `index information' shown above, the multi-index relations are represented by two mappings:

\begin{itemize}
  \item
    \textbf{Target paths} \\
    A map connecting labels of the source tree with labels of the target.
  \item
    \textbf{Target expressions} \\
    A map connecting index expressions of the source tree with those of the target.
\end{itemize}

With these, \pyop3 has sufficient information to:
(1) select the right layout function from the target axis tree, and
(2) substitute index expressions into the layout function, resulting in a \emph{substituted layout function} that accepts multi-indices of the source axis tree instead of the target.
This approach allows \pyop3 to represent indexing operations symbolically as views, regardless of the indexing operation applied.
This contrasts with \numpy where only `simple' indexing operations are supported without copying the array.

\begin{example}{Linear index trees} \label{example:linear_index_tree}

\begin{figure}
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # index the array
      indexed_dat = dat[::2, 1::]?\label{code:index_linear_apply}?
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_linear_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout.pdf}
    \caption{
      The axis tree transformation.
    }
    \label{fig:index_linear_transform}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
  \label{fig:index_linear}
\end{figure}

To illustrate axis tree indexing with a simple example, we consider the operation shown in \cref{fig:index_linear_transform}.
In it we index a linear axis tree using two slices, one for each of the axes (labelled $a$ and $b$).
Code for the transformation is shown in \cref{fig:index_linear_code}.

From \cref{fig:index_linear} we may make several observations:

\begin{itemize}
  \item
    The indexed axis tree (\cref{fig:index_linear_transform}, right) is smaller than the unindexed one and it has new labels: $c$ and $d$ instead of $a$ and $b$.

  \item
    The mapping between old and new axis entries are indicated by their labels.
    For example, the notation $c_2/a_4$ means that axis entry $c_2$ maps to $a_4$ in the original axis tree.

  \item
    Both slices in the index tree (\cref{fig:index_linear_transform}, middle) have a single component.
    No component labels are specified as the input axis tree is linear and so there is no ambiguity.

  \item
    The \pycode{Dat} in \cref{fig:index_linear_code} is not explicitly indexed with an index tree.
    Instead it is indexed with the pair of slices \pycode{[::2, 1::]} (line~\ref{code:index_linear_apply}) that are internally converted into an index tree.
    This syntactic sugar facilitates writing concise code and means that the syntax here is identical to the equivalent \numpy code for an array with shape \pycode{(5, 3)}.
\end{itemize}

Alongside the creation of a new axis tree, indexing the array produces the following index information:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{ c, d \} \to \{a, b\}$ & $\{i_a = 2 i_c,\ i_b = i_d+1\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

Here, the target path store the fact that the path through the source tree $\{c,d\}$ is equivalent to the path through the target tree $\{a,b\}$.
The target expressions capture the semantics of the slices.
Indexing axis $a$ with the slice \pycode{[::2]}, for example, means that entries in the new axis ($c$) map to even entries in $a$ - which is exactly the index expression $i_a = 2i_c$.

Given this information, we may now construct a substituted layout function for addressing the original array with multi-indices of the indexed axis tree.
From the target path we know that the correct, unsubstituted, layout function is

\begin{equation*}
  \textnormal{offset}(i_a, i_b) = 3 i_a + i_b,
\end{equation*}

\noindent
which, applying the target expression substitutions, produces the substituted layout function

\begin{equation*}
  \textnormal{offset}(i_c, i_d) = 6 i_c + i_d + 1
\end{equation*}

\noindent
as desired.

\end{example}

\begin{example}{Multi-component index trees}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis({"x": 3, "y": 2}, "a")
      axis_b = Axis(2, "b")
      axis_c = Axis(3, "c")
      axes = AxisTree.from_nest({axis_a: [axis_b, axis_c]})
      dat = Dat(axes)

      # create the index tree
      index_a = Slice("a", [Subset("x", [0, 2]),
                            AffineSliceComponent("y", start=1)])
      index_b = ScalarIndex("b", 1)
      index_c = Slice("c", [Subset([1, 2])])
      index_tree = IndexTree.from_nest({index_a: [index_b, index_c]})?\label{code:multi_component_make_index_tree}?

      # index the array
      indexed_dat = dat[index_tree]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:multi_component_slice_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[scale=.9]{multi_component_slice_transform.pdf}
    \caption{
      The axis tree transformation.
    }
    \label{fig:multi_component_slice_transform_flowchart}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a multi-component axis tree with a multi-component index tree.
  }
  \label{fig:multi_component_slice}
\end{figure}

As a further example of indexing transformations we consider a multi-component index tree (\cref{fig:multi_component_slice}).
Compared with the linear case there are a number of changes:

\begin{itemize}
  \item
    The slice over axis $a$ now has two components, one slicing the $x$ axis component and one the $y$ component.
    This means that the indexed axis tree (\cref{fig:multi_component_slice_transform_flowchart}, right) has two components also.

  \item
    Some of the slices now include \emph{subsets}.
    Instead of providing \pycode{start}, \pycode{stop}, and \pycode{step} arguments an integer array is provided.
    This is equivalent to `integer array indexing' for \numpy (\cref{sec:numpy_indexing_arrays}).

  \item
    Instead of a slice, axis $b$ is indexed with a \emph{scalar index}.
    This accesses just one of the indices in $b$ and so the index transformation does not need to produce a new axis tree.

  \item
    Unlike the linear case, it is no longer possible to hide the index tree behind syntactic sugar and it must instead be explicitly constructed (\cref{fig:multi_component_slice_code}, line~\ref{code:multi_component_make_index_tree}).
\end{itemize}

Indexing the array as described produces the following target path and target expressions:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{d^t\} \to \{a^x,b\}$ & $\{i_a = \pycode{[0,2][?$i_d$?]},\ i_b = 1\}$ \\
    \hline
    $\{d^u,e\} \to \{a^y,c\}$ & $\{i_a = i_d + 1,\ i_c = \pycode{[1,2][?$i_e$?]}\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

Unlike the linear case above, having subsets introduces index expressions like $\pycode{[0,2][?$i_d$?]}$, and the scalar index of axis $b$ means that $i_b$ is simply a constant, rather than an expression of some other axis index.
With these target paths and expressions it is now straightforward to again determine appropriate substituted layouts for the indexed axis tree:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
    \hline[1pt]
    \textbf{Path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
    \hline[1pt]
    $\{a^x, b\}$ & $\textnormal{offset}(i_a, i_b) = 2 i_a + i_b$ & $\textnormal{offset}(i_d) = 2 ( \pycode{[0,2][?$i_d$?]} ) + 1$ \\
    \hline
    $\{a^y, c\}$ & $\textnormal{offset}(i_a, i_c) = 3 i_a + i_c + 6$ & $\textnormal{offset}(i_d, i_e) = 3(i_d+1) + \pycode{[1,2][?$i_e$?]} + 6$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\end{example}

\subsection{Index composition}
\label{sec:index_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # use indexed_dat from ?\cref{fig:index_linear}?
      indexed_dat = ...

      # index the array again
      indexed_dat2 = indexed_dat[1::, 1]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_composition_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_transform.pdf}
    \caption{The axis tree transformation.}
    \label{fig:index_composition_transform}
  \end{subfigure}

  \caption{
    The composition of an already indexed axis tree (from \cref{fig:index_linear}) with another index tree.
  }
  \label{fig:index_composition}
\end{figure}

Since indexing an axis tree just gives back another axis tree, it is straightforward to repeat the process and index the axis tree again.
An example composition operation is shown in \cref{fig:index_composition}.
Using the indexed array from \cref{fig:index_linear} we index it again to produce another indexed axis tree that remains capable of mapping multi-indices back to the original target axis tree.

If we disregard the prior indexing information and simply treat the transformation as we would a `normal' indexing operation, we get the following index information:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{e\} \to \{ c, d \}$ & $\{ i_c = i_e + 1,\ i_d = 1 \}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\noindent
The circumstances here are different to previous examples because the `source' axis tree (\cref{fig:index_composition_transform}, left) is already indexed, and hence more work is needed to fully map back to the unindexed target axis tree.
From \cref{example:linear_index_tree} we know that the index information for the `source' tree is given by:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{ c, d \} \to \{a, b\}$ & $\{i_a = 2 i_c,\ i_b = i_d+1\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\noindent
Which may now be \emph{composed} with the new indexing information to produce:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]c|[1pt]}
    \hline[1pt]
    \textbf{Target path} & \textbf{Target expressions} \\
    \hline[1pt]
    $\{e\} \to \{a, b\}$ & $\{i_a = 2 (i_e+1),\ i_b = 2\}$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

\noindent
Enabling one to produce appropriate substituted layouts relating the source and target axis trees:

\begin{center}
  \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
    \hline[1pt]
    \textbf{Path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
    \hline[1pt]
    $\{a,b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_e) = 6 (i_e+1) + 2$ \\
    \hline[1pt]
  \end{tblr}
\end{center}

This ability to compose indexing operations means that \pyop3 is able to to represent \emph{all} indexed arrays symbolically, as views.
This contrasts with \numpy which is only capable of doing this for `simple' indexing operations and otherwise resorts to a copy.

\section{Indexing with outer loops}
\label{sec:outer_loops}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

% unlike with slices, the indexed object is parametrised by the loop index, does not make sense in another scope

% outer loops are important for packing code (see ch. 1)
% the packed object has some dependence on the outer index

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% the simplest case is that of a loop index (like c_i in intro).
% give an example.

\begin{figure}[h]
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # create the "outer" loop index
      p = axis_a.index()

      # index the array
      indexed_dat = dat[p, :]
    \end{pyalg2}

    \caption{TODO}
    \label{fig:loop_index_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{loop_index_linear_tree_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis is no longer present in the final axis tree as it has been fully indexed.
    }
    \label{fig:loop_index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      \{$b$\} & $\{a,\ b\}$ & $\{i_a = L^p_a,\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the target expression for axis $a$ is the \textit{loop index} $L^p_a$.
      This means that the indexed axis tree cannot be interpreted without the outer loop $p$ being present.
    }
    \label{fig:loop_index_linear_tree_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b) = 3 L^p_a + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_linear_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation equivalent to indexing a \numpy array with shape \pycode{(5, 3)} with indices \pycode{[p, ::]}, where \pycode{p} is an index coming from some outer loop.
    The resulting array has shape \pycode{(3,)} because the outermost loop has been fully indexed by \pycode{p}.
  }
  \label{fig:loop_index_linear_tree_data_layout_all}
\end{figure}

\subsection{Maps}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      ...
      axes = AxisTree.from_iterable(...)
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 code that indexes an array with a map.}
    \label{fig:map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis has been replaced by the map axis $c$.
    }
    \label{fig:index_map_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Using a map means that the index for axis $a$ is an expression containing both the outer loop index ($L^p_a$) and an index over the shape coming from the map's arity ($i_c$).
    }
    \label{fig:index_map_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b, i_c) = 3 f(L^p_a, i_c) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation representing the packing of an axis tree with shape \pycode{(5, 3)} containing the entries referenced by the map $f(p)$, where $p$ is some outer loop index.
    The map has arity 3, so the resulting array has shape \pycode{(3, 3)}.
  }
  \label{fig:index_map}
\end{figure}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

% explain what arity is, it leads to extra shape!
% they need outer loop indices
% expressions are of the form f(i, j), could be an affine transformation or a lookup

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      dat = Dat(Axis(4, "a"))

      # create the "outer" loop and loop index
      axis_x = Axis(3, "x")
      p = axis_x.index()

      # create a ragged map mapping from "x" to "a"
      arity_dat = Dat(axis_x, data=[2, 0, 1])
      f = Map({"x": [MapComponent("a", arity=arity_dat, ...)]})

      # index the array
      indexed_dat = dat[f(p)]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_ragged_map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_ragged_map_transform.pdf}
    \caption{Axis tree transformation.}
    \label{fig:index_ragged_map_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{b\}$ & $\{a\}$ & $\{i_a = f(L^p_a, i_b)\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a\}$ & $\textnormal{offset}(i_a) = i_a$ & $\textnormal{offset}(i_b) = f(L^p_a, i_b)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_subst_layouts}
  \end{subfigure}

  \caption{
    Example indexing an array with a ragged map.
    The resulting array has variable size depending on the value of the loop index $L^p_a$.
  }
  \label{fig:index_ragged_map}
\end{figure}

There are occasions where maps have variable arity, for example the map mapping from vertices in a mesh to its supported edges ($\support(v)$).
In \pyop3 it is straightforward to create maps with a variable arity by providing an array for the arity instead of an integer.
This is demonstrated in \cref{fig:index_ragged_map}.

\subsubsection{Map composition}
\label{sec:indexing_map_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axes = AxisTree.from_iterable([Axis(5, "a"), Axis(3, "b")])
      dat = Dat(axes)

      # create the "outer" loop and loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # create map f, mapping "x" to "y"
      f = Map({"x": [MapComponent("y", arity=3, ...)]})

      # create map g, mapping "y" to "a"
      g = Map({"y": [MapComponent("a", arity=2, ...)]})

      # index the array
      indexed_dat = dat[g(f(p)), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_composition_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_composition_transform.pdf}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ d,\ b\}$ & $\{a,\ b\}$ & $\{i_a = g(f(L^p_a, i_c), i_d),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c, i_d, i_b) = 3 g(f(L^p_a, i_c), i_d) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_subst_layout}
  \end{subfigure}

  \caption{TODO}
  \label{fig:index_map_composition}
\end{figure}

As described in \cref{sec:foundations_dmplex}, it is occasionally desirable to compose maps such that the output of one feeds directly into another.
This is natural to express in \pyop3 (\cref{fig:index_map_composition}).
Note that, since $f$ and $g$ each have an associated arity, the resulting array gains two additional axes.

\section{Data layout transformations}
\label{sec:indexing_data_layout_transformations}

% It is worthwhile to note that the input axis tree (\pycode{old_axis_tree}) is passed into the function but not really used to construct the new tree... (ref alg:index_axis_tree)

\begin{figure}
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_b, axis_a])
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_swap_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_swap_transform.pdf}
    \caption{TODO}
    \label{fig:index_map_swap_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 5 i_b + i_a$ & $\textnormal{offset}(i_b, i_c) = 5 i_b + f(L^p_a, i_c)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_ subst_layout}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
\end{figure}

% when we index things at some point we must know the arrangement of the DoFs (when we pass to local kernel).

The way that index trees prescribe the layout of the indexed axis tree means that one can compute with alternative data layouts (\cref{sec:axis_tree_alternative_layouts}) without needing to make any changes to the indexing code at all.

This is demonstrated in \cref{fig:index_map_swap} which performs the same packing operation as \cref{fig:index_map} but with the axes $a$ and $b$ swapped around.
Observe that the resulting array (\cref{fig:index_map_swap_transform}) and indexing information (\cref{fig:index_map_swap_axis_info}) are identical to that for \cref{fig:index_linear_axis_info}, but that the final layout function differs from the unswapped version: $\textnormal{offset}() = ???$ instead of $\textnormal{offset}() = ???$.

% but need to be explicit about the labels - order matters

\end{document}
