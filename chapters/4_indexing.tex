\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Indexing}
\label{chapter:indexing}

In array codes it is very rarely the case that the entire array is operated on as a single unit.
Instead, what more commonly happens is the array is restricted to a smaller piece (e.g. a single value) so that it may be read or modified.
This operation is almost universally referred to as \textit{array indexing}.
In this chapter we introduce the necessary abstractions and algorithms required to index axis trees in \pyop3.

\section{Motivation}  % maybe not actually a section... like chapter 3

% NOTE: has been copied to Firedrake chapter - I think leave here as well.
\begin{figure}
  \centering
  \includegraphics{scott_vogelius_index_tree.pdf}
  \caption{Index tree representing the packing transformation shown in \cref{fig:scott_vogelius_element_dof_layout_packed}.}
  \label{fig:scott_vogelius_element_index_tree}
\end{figure}

% reference the bits in chapter 1 - need to transform global to local

% 1. We still have a tree-like structure
% 2. The tree is parametrised by the cell
% 3. therefore we need another tree structure to represent this

The transformation in \cref{fig:scott_vogelius_element_dof_layout_packed} demonstrates that one needs to be able to construct axis trees that are parametrised views of another axis tree.
One can see that the different axes are handled differently, and that the resulting data structure has a similar but not identical tree structure.

\section{Index trees}
\label{sec:index_trees}

In \pyop3, indexing is accomplished via the use of \textit{index trees}.
Analogously to axis trees, index trees consist of multiple \textit{index} objects, each of which has one or more \textit{index components}.

% now talk about how index trees work, what are indices?
% needs more detail, compare tree structure to axis tree (like chapter 3)?
% just like an axis tree has components and axes, an index tree has...

\subsection{Indexing axis trees with index trees}

When an axis tree is indexed, it is transformed via composition with an index tree:

\begin{equation*}
  \textnormal{Axis tree} \quad \circ \quad \textnormal{Index tree} \quad \to \quad \textnormal{Indexed axis tree}
\end{equation*}

This composition operation yields a new \textit{indexed} axis tree.

\begin{algorithm}
  \begin{pyalg2}
    def index_axes(index: Index, old_axis_tree: AxisTree):
      # process the current index
      axis_tree, target_paths, target_exprs = \
        index_handler(index, old_axis_tree)

      for component in index.components:
        if has_subindex(index, component):
          # recursively visit child indices
          subindex = get_subindex(index, component)
          subaxis_tree, subtarget_paths, subtarget_exprs = \
            index_axes(subindex, old_axis_tree)

          axis_tree.add_subtree(subaxis_tree)
          target_paths.update(subtarget_paths)
          target_exprs.update(subtarget_exprs)

      return axis_tree, target_paths, target_exprs
  \end{pyalg2}

  \caption{
    Algorithm that constructs the necessary components to build an indexed axis tree by visiting the nodes of an index tree.
  }
  \label{alg:index_axis_tree}
\end{algorithm}

The construction of an indexed axis tree from an axis tree and index tree is accomplished via a traversal of the index tree (\cref{alg:index_axis_tree}).
Each index of the tree is processed by the function \pycode{index_handler} (line XXX) to give an axis tree and set of targets paths and expressions specific to that index.
These axis trees are then glued together (line YYY) to give the axis tree for the final object while the target paths and target expressions are similarly combined (lines AAA and BBB).
Finally, once collected, the three returned variables may be used to construct a finished indexed axis tree.

The original axis tree (\pycode{old_axis_tree}) plays only a small role in the indexing algorithm.
It is used to determine the sizes of sliced axes and consistency checks.

\subsubsection{Example 1: Linear axis trees}

% TODO: explain how the ordering of paths does not matter - reference data layout transformations
\begin{figure}[h]
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # index the array
      indexed_dat = dat[::2, 1::]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_linear_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout.pdf}
    \caption{
      Diagram of the data layout transformation.
      The original axis tree (left) is composed with an index tree (middle) to produce a new, indexed, axis tree (right).
      The bracketed values in the final tree show the original array entries that they map to.
    }
    \label{fig:index_linear_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{ c,\ d \}$ & $\{a,\ b\}$ & $\{i_a = 2 i_c,\ i_b = i_d+1\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:index_linear_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c, i_d) = 6 i_c + i_d + 1$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_linear_subst_layout}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
  \label{fig:index_linear}
\end{figure}

To illustrate this with a simple example, consider the indexing operation shown in \cref{fig:index_linear_tree_all}.
It shows a slicing operation applied to a linear axis tree with shape \pycode{(5, 3)} and axes labelled $a$ and $b$.
The index tree is also linear and consists of two \textit{slice} objects over the axes $a$ and $b$ respectively with the former taking every other entry in $a$ (\pycode{[::2]}) and the latter taking all but the first entry in $b$ (\pycode{[1::]}).
The indexed axis tree resulting from the composition of these trees is shown to the right: only the selected indices from axes $a$ and $b$ are present and the axes have been relabelled (arbitrarily) $c$ and $d$.

\subsubsection{Example 2: Multi-component axis trees}

\begin{figure}[h]
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis({"x": 3, "y": 2}, "a")
      axis_b = Axis(2, "b")
      axis_c = Axis(3, "c")
      axes = AxisTree.from_nest({axis_a: [axis_b, axis_c]})
      dat = Dat(axes)

      # create the index tree
      index_a = Slice("a", [Subset("x", [0, 2]),
                            AffineSliceComponent("y", start=1)])
      index_b = ScalarIndex("b", 1)
      index_c = Slice("c", [Subset([1, 2])])
      index_tree = IndexTree.from_nest({index_a: [index_b, index_c]})

      # index the array
      indexed_dat = dat[index_tree]
    \end{pyalg2}

    \caption{\pyop3 code that indexes a multi-component array with an index tree.}
    \label{fig:multi_component_slice_code}
  \end{subfigure}

  \vspace{1em}
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics[scale=.9]{multi_component_slice_transform.pdf}
    \caption{
      Diagram of the data layout transformation.
      ...
    }
    \label{fig:multi_component_slice_transform_flowchart}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{d^t\}$ & $\{a^x,\ b\}$ & $\{i_a = \pycode{[0, 2][?$i_d$?]},\ i_b = 1\}$ \\
      \hline
      $\{d^u,\ e\}$ & $\{a^y,\ c\}$ & $\{i_a = i_d + 1,\ i_c = \pycode{[1, 2][?$i_e$?]}\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:multi_component_slice_transform_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a^x,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 2 i_a + i_b$ & $\textnormal{offset}(i_d) = 2 ( \pycode{[0, 2][?$i_d$?]} ) + 1$ \\
      \hline
      $\{a^y,\ c\}$ & $\textnormal{offset}(i_a, i_c) = 3 i_a + i_c + 6$ & $\textnormal{offset}(i_d, i_e) = 3(i_d+1) + \pycode{[1, 2][?$i_e$?]} + 6$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_multi_component_tree_subst_layout}
  \end{subfigure}

  \caption{
    TODO
    The axis tree transformation resulting from indexing a linear axis tree with shape $(5, 3)$ with the slices (\pycode{::2}) and (\pycode{1::}) on axes $a$ and $b$ respectively.
    The resulting axis tree has shape $(3, 2)$ and different labels: $c$ and $d$.
  }
  \label{fig:multi_component_slice}
\end{figure}

% includes subsets, not just slices
% slices may have multiple components, and target specific axis components

\subsection{View-like semantics for indexed axis trees}

Just like axis trees, indexed axis trees need to be able to map multi-indices to offsets.
The difference, however, is that when an axis tree is indexed then a new set of multi-indices is required that reference the indexed tree.
The indexed axis tree therefore must be capable of mapping from a multi-index targetting it to another multi-index targetting the original axis tree.
We therefore call the indexed tree the \textit{source} and the original tree the \textit{target}.

Indexed axis trees behave in the same way as regular axis trees with a small number of exceptions:

\begin{itemize}
  \item
    Indexed axis trees are fully immutable.
    Operations that add or remove axes from the tree are not permitted.

  \item
    To represent the fact that the indexed axis tree is a view of some other axis tree it carries two properties that allow it to map a multi-index with the labels matching the indexed axis tree to a multi-index with labels matching the original axis tree: \textit{target paths} and \textit{target expressions}.
\end{itemize}

\paragraph{Target paths}

The target path is a map from the source tree to the axis labels of the target tree.
It allows \pyop3 to know where the source axes came from so it can select the right layout functions (\cref{sec:layouts}) from the target tree.
In \cref{fig:index_linear_tree_exprs}, the target path shows that source axes $c$ and $d$ map back to $a$ and $b$ in the original array.

\paragraph{Target expressions}

For an indexed axis tree, the target expressions relate the source indices to the target indices as a distinct symbolic expression per target axis.
In \cref{fig:index_linear_tree_exprs} the two target expressions are shown to be $i_a = 2 i_c$ and $i_b = i_d + 1$, telling us that $c_m$ maps to $a_{2m}$ and that $d_n$ maps to $b_{n+1}$ respectively.

The term \textit{target} was chosen as one can consider indexed axis trees to map from themselves (the \textit{source}) to the original axis tree (the \textit{target}).

With these two pieces of information, it is now possible to implement view-like semantics for indexed axis trees.
One simply has to:

\begin{enumerate}
  \item
    Use the target path to select the appropriate layout function from the target axis tree.
  \item
    Modify the layout function by substituting the target indices in the function with the source indices as described by the target expressions attribute of the indexed tree.
  \item
    Evaluate the offset using the new layout function (that is now a function of the source indices rather than the target indices).
\end{enumerate}

% example 1 - now shown in the table...
Applying these steps using the indexing operation of \cref{fig:index_linear_tree_all}, we have:

\begin{enumerate}
  \item
    % TODO: Provide more detail about source paths and how this is retrieved.
    The target paths are $\{c \to a,\ d \to b\}$, so the selected layout function is
    \begin{equation*}
      \textnormal{offset}(i_a, i_b) = 3 i_a + i_b.
    \end{equation*}
  \item
    Substituting the target expressions in \cref{fig:index_linear_tree_exprs}, we get the new layout function
    \begin{equation*}
      \textnormal{offset}(i_c, i_d) = 6 i_c + i_d + 1.
    \end{equation*}
  \item
    The original axis tree may now be addressed using the source indices $i_c$ and $i_d$.
\end{enumerate}

% describe something about subsets for the second example.

\subsection{Index composition}
\label{sec:index_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # use indexed_dat from ?\cref{fig:index_linear}?
      indexed_dat = ...

      # index the array again
      indexed_dat2 = indexed_dat[1::, 1]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_transform.pdf}
    \caption{
      TODO
    }
    \label{fig:index_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Int. path} & \textbf{Int. expressions} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{e\}$ & $\{ c,\ d \}$ & $\{ i_c = i_e + 1,\ i_d = 1 \}$ & $\{a,\ b\}$ & $\{i_a = 2 (i_e+1),\ i_b = 2\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{TODO}
    \label{fig:index_composition_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c) = 6 (i_e+1) + 2$ \\
      \hline[1pt]
    \end{tblr}
    \caption{TODO}
    \label{fig:index_composition_subst_layout}
  \end{subfigure}

  \caption{
    The composition of an already indexed axis tree (from \cref{fig:index_linear_tree_all}) with another index tree.
    Since a scalar index is used, the axis tree ``loses shape" and is transformed from one with shape (3, 2) to one with shape (2,).
    The resulting axis tree can still be mapped correctly back to the original unindexed axis tree.
  }
  \label{fig:index_composition_linear_tree_all}
\end{figure}

Since indexing an axis tree gives back another (indexed) axis tree, it is possible to index the newly created tree using the same code as before.
Index composition is useful in cases where one wants to handle array views in the same way that one might handle unindexed arrays.
This could occur, for instance, if one were to index a vector-valued array to give a view of the array as though it were scalar-valued.
Since the axis trees of both the vector-valued view and the scalar-valued array are identical they may be treated the same way by \pyop3.

An example composition operation is shown in \cref{fig:index_composition}.
The indexed array from \cref{fig:index_linear} is used as input and the array is further sliced.

% how does it differ from the others? intermediate paths and expressions


\section{Indexing with outer loops}
\label{sec:outer_loops}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

% unlike with slices, the indexed object is parametrised by the loop index, does not make sense in another scope

% outer loops are important for packing code (see ch. 1)
% the packed object has some dependence on the outer index

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% the simplest case is that of a loop index (like c_i in intro).
% give an example.

\begin{figure}[h]
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_a, axis_b])
      dat = Dat(axes)

      # create the "outer" loop index
      p = axis_a.index()

      # index the array
      indexed_dat = dat[p, :]
    \end{pyalg2}

    \caption{TODO}
    \label{fig:loop_index_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{loop_index_linear_tree_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis is no longer present in the final axis tree as it has been fully indexed.
    }
    \label{fig:loop_index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      \{$b$\} & $\{a,\ b\}$ & $\{i_a = L^p_a,\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the target expression for axis $a$ is the \textit{loop index} $L^p_a$.
      This means that the indexed axis tree cannot be interpreted without the outer loop $p$ being present.
    }
    \label{fig:loop_index_linear_tree_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b) = 3 L^p_a + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_linear_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation equivalent to indexing a \numpy array with shape \pycode{(5, 3)} with indices \pycode{[p, ::]}, where \pycode{p} is an index coming from some outer loop.
    The resulting array has shape \pycode{(3,)} because the outermost loop has been fully indexed by \pycode{p}.
  }
  \label{fig:loop_index_linear_tree_data_layout_all}
\end{figure}

\subsection{Maps}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      ...
      axes = AxisTree.from_iterable(...)
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 code that indexes an array with a map.}
    \label{fig:map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_data_layout.pdf}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis has been replaced by the map axis $c$.
    }
    \label{fig:index_map_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Using a map means that the index for axis $a$ is an expression containing both the outer loop index ($L^p_a$) and an index over the shape coming from the map's arity ($i_c$).
    }
    \label{fig:index_map_data_layout_exprs}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_b, i_c) = 3 f(L^p_a, i_c) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_subst_layout}
  \end{subfigure}

  \caption{
    Index transformation representing the packing of an axis tree with shape \pycode{(5, 3)} containing the entries referenced by the map $f(p)$, where $p$ is some outer loop index.
    The map has arity 3, so the resulting array has shape \pycode{(3, 3)}.
  }
  \label{fig:index_map}
\end{figure}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

% explain what arity is, it leads to extra shape!
% they need outer loop indices
% expressions are of the form f(i, j), could be an affine transformation or a lookup

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      dat = Dat(Axis(4, "a"))

      # create the "outer" loop and loop index
      axis_x = Axis(3, "x")
      p = axis_x.index()

      # create a ragged map mapping from "x" to "a"
      arity_dat = Dat(axis_x, data=[2, 0, 1])
      f = Map({"x": [MapComponent("a", arity=arity_dat, ...)]})

      # index the array
      indexed_dat = dat[f(p)]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_ragged_map_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_ragged_map_transform.pdf}
    \caption{Axis tree transformation.}
    \label{fig:index_ragged_map_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{b\}$ & $\{a\}$ & $\{i_a = f(L^p_a, i_b)\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a\}$ & $\textnormal{offset}(i_a) = i_a$ & $\textnormal{offset}(i_b) = f(L^p_a, i_b)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_ragged_map_subst_layouts}
  \end{subfigure}

  \caption{
    Example indexing an array with a ragged map.
    The resulting array has variable size depending on the value of the loop index $L^p_a$.
  }
  \label{fig:index_ragged_map}
\end{figure}

There are occasions where maps have variable arity, for example the map mapping from vertices in a mesh to its supported edges ($\support(v)$).
In \pyop3 it is straightforward to create maps with a variable arity by providing an array for the arity instead of an integer.
This is demonstrated in \cref{fig:index_ragged_map}.

\subsubsection{Map composition}
\label{sec:indexing_map_composition}

\begin{figure}
  \centering

  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axes = AxisTree.from_iterable([Axis(5, "a"), Axis(3, "b")])
      dat = Dat(axes)

      # create the "outer" loop and loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # create map f, mapping "x" to "y"
      f = Map({"x": [MapComponent("y", arity=3, ...)]})

      # create map g, mapping "y" to "a"
      g = Map({"y": [MapComponent("a", arity=2, ...)]})

      # index the array
      indexed_dat = dat[g(f(p)), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_composition_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_composition_transform.pdf}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ d,\ b\}$ & $\{a,\ b\}$ & $\{i_a = g(f(L^p_a, i_c), i_d),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ & $\textnormal{offset}(i_c, i_d, i_b) = 3 g(f(L^p_a, i_c), i_d) + i_b$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_composition_subst_layout}
  \end{subfigure}

  \caption{TODO}
  \label{fig:index_map_composition}
\end{figure}

As described in \cref{sec:foundations_dmplex}, it is occasionally desirable to compose maps such that the output of one feeds directly into another.
This is natural to express in \pyop3 (\cref{fig:index_map_composition}).
Note that, since $f$ and $g$ each have an associated arity, the resulting array gains two additional axes.

\section{Data layout transformations}
\label{sec:indexing_data_layout_transformations}

% It is worthwhile to note that the input axis tree (\pycode{old_axis_tree}) is passed into the function but not really used to construct the new tree... (ref alg:index_axis_tree)

\begin{figure}
  \centering
  \begin{subfigure}{.9\textwidth}
    \begin{pyalg2}
      # set up the axis tree and array
      axis_a = Axis(5, "a")
      axis_b = Axis(3, "b")
      axes = AxisTree.from_iterable([axis_b, axis_a])
      dat = Dat(axes)

      # create a map mapping from axis "x" to "a"
      f = Map({"x": [MapComponent("a", arity=3, ...)]})

      # create the "outer" loop index
      axis_x = Axis(10, "x")
      p = axis_x.index()

      # index the array
      indexed_dat = dat[f(p), :]
    \end{pyalg2}

    \caption{\pyop3 indexing code.}
    \label{fig:index_map_swap_code}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_swap_transform.pdf}
    \caption{TODO}
    \label{fig:index_map_swap_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]c|[1pt]c|[1pt]}
      \hline[1pt]
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline[1pt]
      $\{c,\ b\}$ & $\{a,\ b\}$ & $\{i_a = f(L^p_a, i_c),\ i_b = i_b\}$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_axis_info}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tblr}{|[1pt]c|[1pt]l|[1pt]l|[1pt]}
      \hline[1pt]
      \textbf{Target path} & \SetCell{c}\textbf{Original layout} & \SetCell{c}\textbf{Substituted layout} \\
      \hline[1pt]
      $\{a,\ b\}$ & $\textnormal{offset}(i_a, i_b) = 5 i_b + i_a$ & $\textnormal{offset}(i_b, i_c) = 5 i_b + f(L^p_a, i_c)$ \\
      \hline[1pt]
    \end{tblr}
    \caption{
      TODO
    }
    \label{fig:index_map_swap_ subst_layout}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
  \label{fig:index_linear}
\end{figure}

% when we index things at some point we must know the arrangement of the DoFs (when we pass to local kernel).

The way that index trees prescribe the layout of the indexed axis tree means that one can compute with alternative data layouts (\cref{sec:axis_tree_alternative_layouts}) without needing to make any changes to the indexing code at all.

This is demonstrated in \cref{fig:index_map_swap} which performs the same packing operation as \cref{fig:index_map} but with the axes $a$ and $b$ swapped around.
Observe that the resulting array (\cref{fig:index_map_swap_transform}) and indexing information (\cref{fig:index_map_swap_axis_info}) are identical to that for \cref{fig:index_linear_axis_info}, but that the final layout function differs from the unswapped version: $\textnormal{offset}() = ???$ instead of $\textnormal{offset}() = ???$.

% but need to be explicit about the labels - order matters

\end{document}
