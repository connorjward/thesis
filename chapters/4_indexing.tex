\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Indexing}

In array codes it is very rarely the case that the entire array is operated on as a single unit.
Instead, what more commonly happens is the array is restricted to a smaller piece (e.g. a single value) so that it may be read or modified.
This operation is almost universally referred to as \textit{array indexing}.
In this chapter we introduce the necessary abstractions and algorithms required to index axis trees in \pyop3.

\section{Index trees}
\label{sec:index_trees}

In \pyop3, indexing is accomplished via the use of \textit{index trees}.
Analogously to axis trees, index trees consist of multiple \textit{index} objects, each of which has one or more \textit{index components}.
When an axis tree is indexed, it is transformed via composition with an index tree:

\begin{equation*}
  \textnormal{Axis tree} \quad \circ \quad \textnormal{Index tree} \quad \to \quad \textnormal{Indexed axis tree}
\end{equation*}

This composition operation yields a new \textit{indexed} axis tree that understand how its entries map back to the original axis tree.
In other words, it is a \textit{view}.

% TODO: Get rid of source path, instead target path is a mapping c -> a, d -> b
% TODO: Possibly explain how the ordering of things does not matter.
% TODO: Add labels to individual entries in the array and propagate them, put labels outside.
% TODO: For the target expressions use "=", not ":"
\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout}
    \caption{
      Diagram of the data layout transformation.
      The original axis tree (left) is composed with an index tree (middle) to produce a new, indexed, axis tree (right).
      The bracketed values in the final tree show the original array entries that they map to.
    }
    \label{fig:index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $d$\} & \{$a$, $b$\} & \{$i_a$: $2 i_c$, $i_b$: $i_d+1$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:index_linear_tree_exprs}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape \pycode{(5, 3)} with slices \pycode{[::2]} and \pycode{[1::]} on axes $a$ and $b$ respectively.
    The resulting axis tree has shape \pycode{(3, 2)} and different labels: $c$ and $d$.
  }
  \label{fig:index_linear_tree_all}
\end{figure}

To illustrate this with a simple example, consider the indexing operation shown in \cref{fig:index_linear_tree_all}.
It shows a slicing operation applied to a linear axis tree with shape \pycode{(5, 3)} and axes labelled $a$ and $b$.
The index tree is also linear and consists of two \textit{slice} objects over the axes $a$ and $b$ respectively with the former taking every other entry in $a$ (\pycode{[::2]}) and the latter taking all but the first entry in $b$ (\pycode{[1::]}).
The indexed axis tree resulting from the composition of these trees is shown to the right: only the selected indices from axes $a$ and $b$ are present and the axes have been relabelled (arbitrarily) $c$ and $d$.

In addition to having a new shape and new labels, the indexed axis tree also carries the information necessary to map back from the indexed shape (the \textit{source}) to the original axis tree (the \textit{target}).
This is done by associating two attributes with the indexed axis tree:

\paragraph{Target paths}

The target path is a map from the source tree to the axis labels of the target tree.
It allows \pyop3 to know where the source axes came from so it can select the right layout functions (\cref{sec:layouts}) from the target tree.
In \cref{fig:index_linear_tree_exprs}, the target path shows that source axes $c$ and $d$ map back to $a$ and $b$ in the original array.

\paragraph{Target expressions}

For an indexed axis tree, the target expressions relate the source indices to the target indices as a distinct symbolic expression per target axis.
In \cref{fig:index_linear_tree_exprs} the two target expressions are shown to be $i_a \coloneq 2 i_c$ and $i_b \coloneq i_d + 1$, telling us that $c_m$ maps to $a_{2m}$ and that $d_n$ maps to $b_{n+1}$ respectively.

With these two pieces of information, it is now possible to implement view-like semantics for indexed axis trees.
One simply has to:

\begin{enumerate}
  \item
    Use the target path to select the appropriate layout function from the target axis tree.
  \item
    Modify the layout function by substituting the target indices in the function with the source indices as described by the target expressions attribute of the indexed tree.
  \item
    Evaluate the offset using the new layout function (that is now a function of the source indices rather than the target indices).
\end{enumerate}

Applying these steps using the indexing operation of \cref{fig:index_linear_tree_all}, we have:

\begin{enumerate}
  \item
    The target path is $\{a, b\}$, so the selected layout function is $\mathrm{offset}(i_a, i_b) = 3 i_a + i_b$.
  \item
    Substituting the target expressions in \cref{fig:index_linear_tree_exprs}, we get the new layout function $\mathrm{offset}(i_c, i_d) = 6 i_c + i_d + 1$.
  \item
    The original axis tree may now be addressed using the source indices $i_c$ and $i_d$.
\end{enumerate}

\subsection{Indexed axis tree construction}

\begin{algorithm}
  \begin{pyalg}
    def index_axes(index, old_axis_tree):
      # process the current index
      axis_tree, target_paths, target_exprs = index_handler(index, old_axis_tree)

      for component in index.components:
        if has_subindex(index, component):
          # recursively visit child indices
          subindex = get_subindex(index, component)
          subaxis_tree, subtarget_paths, subtarget_exprs = index_axes(subindex, old_axis_tree)

          axis_tree.add_subtree(subaxis_tree)
          target_paths |= subtarget_paths
          target_exprs |= subtarget_exprs

      return axis_tree, target_paths, target_exprs
  \end{pyalg}

  \caption{
    Algorithm that constructs the necessary components to build an indexed axis tree by visiting the nodes of an index tree.
  }
  \label{alg:index_axis_tree}
\end{algorithm}

The construction of an indexed axis tree from an axis tree and index tree is accomplished via a traversal of the index tree (\cref{alg:index_axis_tree}).
Each index of the tree is processed by the function \pycode{index_handler} (line XXX) to give an axis tree and set of targets paths and expressions specific to that index.
These axis trees are then glued together (line YYY) to give the axis tree for the final object while the target paths and target expressions are similarly combined (lines AAA and BBB).
Finally, once collected, the three returned variables may be used to construct a finished indexed axis tree.

The original axis tree (\pycode{old_axis_tree}) plays only a small role in the indexing algorithm.
It is used to determine the sizes of sliced axes and consistency checks.

% TODO: use multi-component indexing as an example here

% "Thus far we have only considered the case of linear index trees..."

% motivation: needed since we need to pack clever things
% "proto" axis trees

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{multi_component_slice_transform}
    \caption{
      Diagram of the data layout transformation.
      ...
    }
    \label{fig:multi_component_slice_transform_flowchart}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      % TODO
      % \{$c$, $d$\} & \{$a$, $b$\} & \{$i_a$: $2 i_c$, $i_b$: $i_d+1$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:multi_component_slice_transform_exprs}
  \end{subfigure}

  \caption{
    TODO
    The axis tree transformation resulting from indexing a linear axis tree with shape $(5, 3)$ with the slices (\pycode{::2}) and (\pycode{1::}) on axes $a$ and $b$ respectively.
    The resulting axis tree has shape $(3, 2)$ and different labels: $c$ and $d$.
  }
  \label{fig:multi_component_slice_transform}
\end{figure}


\subsection{Index composition}
\label{sec:index_composition}

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_linear_tree_data_layout}
    \caption{
      The index composition operation.
      All but the first (\pycode{1::}) of axis $c$ is selected with only the second entry in axis $d$.
    }
    \label{fig:index_composition_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$e$\} & \{$a$, $b$\} & \{$i_a$: $2 (i_e+1)$, $i_b$: $2$\} \\
      \hline
    \end{tabular}
    \caption{
      Index expressions and paths relating the indexed ``source" tree back to the original unindexed tree.
      Note how the index for axis $d$ ($i_d$) is not present among the target expressions as it has been substituted for a 1.
    }
    \label{fig:index_composition_linear_tree_exprs}
  \end{subfigure}

  \caption{
    The composition of an already indexed axis tree (from \cref{fig:index_linear_tree_all}) with another index tree.
    Since a scalar index is used, the axis tree ``loses shape" and is transformed from one with shape (3, 2) to one with shape (2,).
    The resulting axis tree can still be mapped correctly back to the original unindexed axis tree.
  }
  \label{fig:index_composition_linear_tree_all}
\end{figure}

\section{Outer loops}
\label{sec:outer_loops}

\begin{figure}[h]
  \centering
  %
  \begin{subfigure}[t]{.48\textwidth}
    \centering
    \begin{minted}{python}
loop(
  i := dat.axes.index(),
  dat[i].assign(666, eager=False),
)
    \end{minted}
    \caption{
      \pyop3 loop expression representing the operation of setting all elements of \pycode{dat} to 666.
      The walrus operator (\pycode{:=}) used here is a feature of Python 3.8 and above and is an \textit{assignment expression}.
      In effect this passes \pycode{dat.axes.index()} as an argument to \pycode{loop} whilst also binding its value to the variable \pycode{i}.
      The keyword argument \pycode{eager=False} is an implementation detail required to enforce that the assignment is a symbolic rather than numeric operation.
    }
    \label{fig:simple_loop_pyop3}
  \end{subfigure}
  %
  \hfill
  %
  \begin{subfigure}[t]{.48\textwidth}
    \centering
    % blank line included to improve horizontal alignment with other subfigure
    \begin{minted}{python}
for i in range(len(numpy_dat)):
  numpy_dat[i] = 666

    \end{minted}
    \caption{
      Python code equivalent to the loop expression shown in \ref{fig:simple_loop_pyop3} where \pycode{dat} has been replaced by a numpy array (\pycode{numpy_dat}).
      For simplicity we assume that \pycode{numpy_dat} is 1-dimensional.
    }
    \label{fig:simple_loop_python}
  \end{subfigure}

  \caption{A comparison of a simple assignment loop written in \pyop3 and numpy/Python.}
  \label{fig:simple_loop}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{loop_index_linear_tree_data_layout}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis is no longer present in the final axis tree as it has been fully indexed.
    }
    \label{fig:loop_index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$b$\} & \{$a$, $b$\} & \{$i_a$: $i^p_a$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the target expression for axis $a$ is the \textit{loop index} $i^p_a$.
      This means that the indexed axis tree cannot be interpreted without the outer loop $p$ being present.
    }
    \label{fig:loop_index_linear_tree_data_layout_exprs}
  \end{subfigure}

  \caption{
    Index transformation equivalent to indexing a numpy array with shape \pycode{(5, 3)} with indices \pycode{[p, ::]}, where \pycode{p} is an index coming from some outer loop.
    The resulting array has shape \pycode{(3,)} because the outermost loop has been fully indexed by \pycode{p}.
  }
  \label{fig:loop_index_linear_tree_data_layout_all}
\end{figure}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

In \pyop3, these outer loops are described by the \pycode{loop(...)} construct.
Calling \pycode{loop} creates a \textit{loop expression}, which is a symbolic object representing the loop to be performed.
The loop expression expects a \textit{loop index}, and a collection of \textit{statements}.
The loop index represents the domain to be iterated over and it has an associated axis tree where each element of the axis tree will be visited.
The statements may be further loops or arbitrary operations (see \cref{ch:dsl} for a more in-depth description).

To give an example, one of the simplest possible loops that one can write in \pyop3 is shown in \cref{fig:simple_loop_pyop3}.
Here the loop index (\pycode{i}) is simply ``all elements of \pycode{dat}`` and there is a single statement that sets each entry in \pycode{dat} to the arbitrary value of 666.
Note that the syntax of the loop expression is deliberately similar to that of Python (or other imperative programming languages).

The challenge here is how to represent the indexing operation \pycode{dat[i]}...

% scalar shape

% meh, we don't really say this
Furthermore, the indexed object is dependent upon the loop index: the target expressions of the axis tree must reference the loop index.
In \pyop3 we say that it is \textit{context-dependent}.

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% subsection on context-sensitivity? ie. expanding the loop contexts? potentially ick, maybe put as a pass in the codegen section?

% How do I introduce this section? How do I motivate it? Kind of want to thread the "do FEM assembly"
% story through this whole bit.
% but try to not explicity use that as an example because I want to save that for the final chapter.
% TODO: Give an example of how it would look in code, introduce CalledMap vs Map
\section{Maps}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_data_layout}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis has been replaced by the map axis $c$.
    }
    \label{fig:index_map_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Using a map means that the index for axis $a$ is an expression containing both the outer loop index ($i^p_a$) and an index over the shape coming from the map's arity ($i_c$).
    }
    \label{fig:index_map_data_layout_exprs}
  \end{subfigure}

  \caption{
    Index transformation representing the packing of an axis tree with shape \pycode{(5, 3)} containing the entries referenced by the map $f(p)$, where $p$ is some outer loop index.
    The map has arity 3, so the resulting array has shape \pycode{(3, 3)}.
  }
  \label{fig:index_map_data_layout_all}
\end{figure}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

% explain what arity is, it leads to extra shape!
% they need outer loop indices
% expressions are of the form f(i, j), could be an affine transformation or a lookup

% they have "target leaves" - bad terminology

\subsection{Ragged maps}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{ragged_map_transform}
    \caption{
      TODO
    }
    \label{fig:ragged_map_transform_flowchart}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      % TODO
      % \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      TODO
    }
    \label{fig:ragged_map_transform_exprs}
  \end{subfigure}

  \caption{
    TODO
  }
  \label{fig:ragged_map_transform}
\end{figure}

Ragged maps are also supported. e.g. support, star, PIC

% arity is now an array

\subsection{Map composition}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{map_composition_transform}
    \caption{
      TODO
    }
    \label{fig:map_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $d$, $b$\} & \{$a$, $b$\} & \{$i_a$: $g(f(i^p_a, i_c), i_d)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      TODO
    }
    \label{fig:map_composition_transform_exprs}
  \end{subfigure}

  \caption{TODO}
  \label{fig:map_composition_transform_all}
\end{figure}

\section{Data layout transformations}

% It is worthwhile to note that the input axis tree (\pycode{old_axis_tree}) is passed into the function but not really used to construct the new tree... (ref alg:index_axis_tree)

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{data_layout_transform}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      TODO
    }
    \label{fig:data_layout_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the values here are entirely identical to those in \cref{fig:index_map_data_layout_exprs}.
      This is because the indexing operations are kept separate from any layout considerations.
    }
    \label{fig:data_layout_transform_exprs}
  \end{subfigure}

  \caption{
    Index transformation equivalent to \cref{fig:index_map_data_layout} apart from the fact that the data layout of the original axis tree has been transposed with axes $a$ and $b$ flipped.
    Despite this, the indexing transformation and resultant indexed tree are exactly the same as they were before.
  }
  \label{fig:data_layout_transform_all}
\end{figure}

With \pyop3's axis trees it is straightforward to construct alternative data layouts for the same data.
This is touched upon in \cref{sec:axis_tree_examples} for the cases of vector and mixed function spaces.
Such alternative layouts can be very beneficial for improving the data access patterns of the data, but it presents a new problem: the packing and unpacking code must be different for the different data layouts.
Conveniently, using index trees allows us to ignore the problem completely.
Since one can think of index trees as being ``proto" axis trees, it is possible to index differently laid out data structures using the same index tree and the resulting temporary will have the same shape as prescribed by the index tree.
% give an example

\end{document}
