\documentclass[thesis]{subfiles}

\begin{document}

% TODO: Somewhere talk about ragged temporaries?

\chapter{Indexing}

Axis trees provide us with a method for describing the data layout of global objects.
In order to be able to execute compact stencils this is insufficient.
We need a way to extract portions of the array such that they may be operated on independently.
In \pyop3, this extraction operation is referred to as \textit{indexing}.
In many cases it is directly equivalent to the same terminology/operation as numpy.

\section{Index trees}
\label{sec:index_trees}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_linear_tree_data_layout}
    \caption{
      Diagram of the data layout transformation.
      The original axis tree (left) is composed with an index tree (see \cref{sec:index_trees}) (middle) to produce a new axis tree (right).
      The bracketed values in the resultant tree show the original indices that they map to.
    }
    \label{fig:index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $d$\} & \{$a$, $b$\} & \{$i_a$: $2 i_c$, $i_b$: $i_d+1$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:index_linear_tree_exprs}
  \end{subfigure}

  \caption{
    The axis tree transformation resulting from indexing a linear axis tree with shape $(5, 3)$ with the slices (\pycode{::2}) and (\pycode{1::}) on axes $a$ and $b$ respectively.
    The resulting axis tree has shape $(3, 2)$ and different labels: $c$ and $d$.
  }
  \label{fig:index_linear_tree_all}
\end{figure}

In \pyop3, indexing is accomplished via the use of \textit{index trees}.
Analogously to axis trees, index trees consist of multiple \textit{index} objects (equivalent to an axis), each of which has one or more \textit{index components}.
When an array is indexed, its associated axis tree is \textit{transformed} via composition with an index tree.
This composition operation yields a new \textit{indexed} axis tree that understand how its entries map back to the original array.
Finally this new axis tree is used to construct a new array object.

To illustrate this with a simple example, consider the indexing operation shown in \cref{fig:index_linear_tree_all}.
It shows a slicing operation applied to a linear axis tree (left) with shape (5, 3) and with axes labelled $a$ and $b$.
The index tree (middle) is also linear and consists of two \textit{slice} objects over the axes $a$ and $b$ respectively with the former taking every even entry in $a$ (\pycode{::2}) and the latter taking all but the first entry in $b$ (\pycode{1::}).
The axis tree resulting from the composition of these trees is shown to the right.
As shown in the figure, only the selected components of the original axis tree are present and the array has additionally received a new label numbering from zero: $c$ and $d$.
This resulting axis tree is in fact an \textit{indexed} axis tree, which differs from an ordinary axis tree in a number of ways:
\begin{itemize}
  \item
    It does not retabulate any layout functions. These are reused from the original, unindexed, axis tree.
  \item
    It knows about the fact that it is indexed and can map back to the original axis tree using \textit{target paths} and \textit{target expressions}.
\end{itemize}

\subsection{Target paths and expressions}
% NOTE: It is arguably confusing that we use "source" and "target" this way around...

When an axis is indexed, two pieces of information need to be retained for the indexed tree to be able to map back to the original array:
(a) which component of the original axis tree is targeted, and
(b) the correct expression taking index values from the indexed tree and mapping them to index values in the original tree.
Of these the former is termed the \textit{target paths} and the latter the \textit{target expressions}.
Due to the notion of mapping \textit{from} the indexed axis tree back \textit{to} the original axis tree, the indexed tree is also called the \textit{source} axis tree and the original tree is the \textit{target}.

For the indexing operation shown in \cref{fig:index_linear_tree_all}, the resulting target paths and target expressions are shown in \cref{fig:index_composition_linear_tree_exprs}.
Since the tree is linear, only a single pair of path and expressions exist mapping the source axes $c$ and $d$ back to the target axes $a$ and $b$.
Regarding the target expressions, it can be seen that the index value for target axis $a$ is given by an expression involving the index associated to source axis $c$: $i_a = 2 i_c$.
This encodes the information that source axis entry $c_0$ maps to $a_0$, $c_1$ maps to $a_2$ etc.
This is clearly shown by the indexed tree in \cref{fig:index_linear_tree_data_layout}.
The same principle applies to axes $b$ and $d$, except that the different slicing pattern means that the target expression now includes an offset.

With the target expressions mapping from the indexed axis tree back to the unindexed one, and with the unindexed tree having layout functions that map from axis variables to offsets, we possess all of the information necessary for the indexed arrays to ``know" what data they in fact contain.
All one needs to do is to replace the axis variables in the layout functions with the target expressions from the indexed tree to get the right mapping from the source axis variables to the right offsets.

\subsection{Multi-component index trees}

% motivation: needed since we need to pack clever things
% "proto" axis trees

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{multi_component_slice_transform}
    \caption{
      Diagram of the data layout transformation.
      ...
    }
    \label{fig:multi_component_slice_transform_flowchart}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      % TODO
      % \{$c$, $d$\} & \{$a$, $b$\} & \{$i_a$: $2 i_c$, $i_b$: $i_d+1$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the transformed axis tree that allows it to map back to the original unindexed tree.
    }
    \label{fig:multi_component_slice_transform_exprs}
  \end{subfigure}

  \caption{
    TODO
    The axis tree transformation resulting from indexing a linear axis tree with shape $(5, 3)$ with the slices (\pycode{::2}) and (\pycode{1::}) on axes $a$ and $b$ respectively.
    The resulting axis tree has shape $(3, 2)$ and different labels: $c$ and $d$.
  }
  \label{fig:multi_component_slice_transform}
\end{figure}

\section{Index composition}
\label{sec:index_composition}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_composition_linear_tree_data_layout}
    \caption{
      The index composition operation.
      All but the first (\pycode{1::}) of axis $c$ is selected with only the second entry in axis $d$.
    }
    \label{fig:index_composition_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$e$\} & \{$a$, $b$\} & \{$i_a$: $2 (i_e+1)$, $i_b$: $2$\} \\
      \hline
    \end{tabular}
    \caption{
      Index expressions and paths relating the indexed ``source" tree back to the original unindexed tree.
      Note how the index for axis $d$ ($i_d$) is not present among the target expressions as it has been substituted for a 1.
    }
    \label{fig:index_composition_linear_tree_exprs}
  \end{subfigure}

  \caption{
    The composition of an already indexed axis tree (from \cref{fig:index_linear_tree_all}) with another index tree.
    Since a scalar index is used, the axis tree ``loses shape" and is transformed from one with shape (3, 2) to one with shape (2,).
    The resulting axis tree can still be mapped correctly back to the original unindexed axis tree.
  }
  \label{fig:index_composition_linear_tree_all}
\end{figure}

\section{Outer loops}
\label{sec:outer_loops}

\begin{figure}[h]
  \centering
  %
  \begin{subfigure}[t]{.48\textwidth}
    \centering
    \begin{minted}{python}
loop(
  i := dat.axes.index(),
  dat[i].assign(666, eager=False),
)
    \end{minted}
    \caption{
      \pyop3 loop expression representing the operation of setting all elements of \pycode{dat} to 666.
      The walrus operator (\pycode{:=}) used here is a feature of Python 3.8 and above and is an \textit{assignment expression}.
      In effect this passes \pycode{dat.axes.index()} as an argument to \pycode{loop} whilst also binding its value to the variable \pycode{i}.
      The keyword argument \pycode{eager=False} is an implementation detail required to enforce that the assignment is a symbolic rather than numeric operation.
    }
    \label{fig:simple_loop_pyop3}
  \end{subfigure}
  %
  \hfill
  %
  \begin{subfigure}[t]{.48\textwidth}
    \centering
    % blank line included to improve horizontal alignment with other subfigure
    \begin{minted}{python}
for i in range(len(numpy_dat)):
  numpy_dat[i] = 666

    \end{minted}
    \caption{
      Python code equivalent to the loop expression shown in \ref{fig:simple_loop_pyop3} where \pycode{dat} has been replaced by a numpy array (\pycode{numpy_dat}).
      For simplicity we assume that \pycode{numpy_dat} is 1-dimensional.
    }
    \label{fig:simple_loop_python}
  \end{subfigure}

  \caption{A comparison of a simple assignment loop written in \pyop3 and numpy/Python.}
  \label{fig:simple_loop}
\end{figure}

\begin{figure}
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{loop_index_linear_tree_data_layout}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis is no longer present in the final axis tree as it has been fully indexed.
    }
    \label{fig:loop_index_linear_tree_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$b$\} & \{$a$, $b$\} & \{$i_a$: $i^p_a$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the target expression for axis $a$ is the \textit{loop index} $i^p_a$.
      This means that the indexed axis tree cannot be interpreted without the outer loop $p$ being present.
    }
    \label{fig:loop_index_linear_tree_data_layout_exprs}
  \end{subfigure}

  \caption{
    Index transformation equivalent to indexing a numpy array with shape \pycode{(5, 3)} with indices \pycode{[p, ::]}, where \pycode{p} is an index coming from some outer loop.
    The resulting array has shape \pycode{(3,)} because the outermost loop has been fully indexed by \pycode{p}.
  }
  \label{fig:loop_index_linear_tree_data_layout_all}
\end{figure}

The indexing routines demonstrated so far are not sufficient for \pyop3's purposes.
If we consider the prototypical finite element assembly loop (\cref{alg:fem_todo}) we see that there is an outer loop over cells, and that the data is packed, or indexed, \textit{relative} to the current cell.

In \pyop3, these outer loops are described by the \pycode{loop(...)} construct.
Calling \pycode{loop} creates a \textit{loop expression}, which is a symbolic object representing the loop to be performed.
The loop expression expects a \textit{loop index}, and a collection of \textit{statements}.
The loop index represents the domain to be iterated over and it has an associated axis tree where each element of the axis tree will be visited.
The statements may be further loops or arbitrary operations (see \cref{ch:dsl} for a more in-depth description).

To give an example, one of the simplest possible loops that one can write in \pyop3 is shown in \cref{fig:simple_loop_pyop3}.
Here the loop index (\pycode{i}) is simply ``all elements of \pycode{dat}`` and there is a single statement that sets each entry in \pycode{dat} to the arbitrary value of 666.
Note that the syntax of the loop expression is deliberately similar to that of Python (or other imperative programming languages).

The challenge here is how to represent the indexing operation \pycode{dat[i]}...

% scalar shape

% meh, we don't really say this
Furthermore, the indexed object is dependent upon the loop index: the target expressions of the axis tree must reference the loop index.
In \pyop3 we say that it is \textit{context-dependent}.

% A loop index has no shape. e.g. axes[p] where p is a loop index is scalar.

% subsection on context-sensitivity? ie. expanding the loop contexts? potentially ick, maybe put as a pass in the codegen section?

% How do I introduce this section? How do I motivate it? Kind of want to thread the "do FEM assembly"
% story through this whole bit.
% but try to not explicity use that as an example because I want to save that for the final chapter.
% TODO: Give an example of how it would look in code, introduce CalledMap vs Map
\section{Maps}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{index_map_data_layout}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      Note how the $a$ axis has been replaced by the map axis $c$.
    }
    \label{fig:index_map_data_layout}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Using a map means that the index for axis $a$ is an expression containing both the outer loop index ($i^p_a$) and an index over the shape coming from the map's arity ($i_c$).
    }
    \label{fig:index_map_data_layout_exprs}
  \end{subfigure}

  \caption{
    Index transformation representing the packing of an axis tree with shape \pycode{(5, 3)} containing the entries referenced by the map $f(p)$, where $p$ is some outer loop index.
    The map has arity 3, so the resulting array has shape \pycode{(3, 3)}.
  }
  \label{fig:index_map_data_layout_all}
\end{figure}

Maps differ from slices because they add additional shape. They have a from index

How to build a map.

% explain what arity is, it leads to extra shape!
% they need outer loop indices
% expressions are of the form f(i, j), could be an affine transformation or a lookup

% they have "target leaves" - bad terminology

\subsection{Ragged maps}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{ragged_map_transform}
    \caption{
      TODO
    }
    \label{fig:ragged_map_transform_flowchart}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      % TODO
      % \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      TODO
    }
    \label{fig:ragged_map_transform_exprs}
  \end{subfigure}

  \caption{
    TODO
  }
  \label{fig:ragged_map_transform}
\end{figure}

Ragged maps are also supported. e.g. support, star, PIC

% arity is now an array

\subsection{Map composition}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{map_composition_transform}
    \caption{
      TODO
    }
    \label{fig:map_composition_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $d$, $b$\} & \{$a$, $b$\} & \{$i_a$: $g(f(i^p_a, i_c), i_d)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      TODO
    }
    \label{fig:map_composition_transform_exprs}
  \end{subfigure}

  \caption{TODO}
  \label{fig:map_composition_transform_all}
\end{figure}

\section{Data layout transformations}

\begin{figure}[h]
  \centering
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{data_layout_transform}
    \caption{
      The data layout transformation from the unindexed axis tree (left) to the indexed one (right).
      TODO
    }
    \label{fig:data_layout_transform}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|c|}
      \hline
      \textbf{Source path} & \textbf{Target path} & \textbf{Target expressions} \\
      \hline
      \{$c$, $b$\} & \{$a$, $b$\} & \{$i_a$: $f(i^p_a, i_c)$, $i_b$: $i_b$\} \\
      \hline
    \end{tabular}
    \caption{
      The indexing information carried by the indexed axis tree (right).
      Note how the values here are entirely identical to those in \cref{fig:index_map_data_layout_exprs}.
      This is because the indexing operations are kept separate from any layout considerations.
    }
    \label{fig:data_layout_transform_exprs}
  \end{subfigure}

  \caption{
    Index transformation equivalent to \cref{fig:index_map_data_layout} apart from the fact that the data layout of the original axis tree has been transposed with axes $a$ and $b$ flipped.
    Despite this, the indexing transformation and resultant indexed tree are exactly the same as they were before.
  }
  \label{fig:data_layout_transform_all}
\end{figure}

With \pyop3's axis trees it is straightforward to construct alternative data layouts for the same data.
This is touched upon in \cref{sec:axis_tree_examples} for the cases of vector and mixed function spaces.
Such alternative layouts can be very beneficial for improving the data access patterns of the data, but it presents a new problem: the packing and unpacking code must be different for the different data layouts.
Conveniently, using index trees allows us to ignore the problem completely.
Since one can think of index trees as being ``proto" axis trees, it is possible to index differently laid out data structures using the same index tree and the resulting temporary will have the same shape as prescribed by the index tree.
% give an example

\end{document}
