\documentclass[thesis]{subfiles}

\begin{document}

% NOTE: Should introduce vectors/Dats here, analogous to numpy in a good way.
\chapter{Axis trees}
\label{chapter:axis_trees}

As we have seen thus far, existing software abstractions for mesh-like data layouts are limited by their ability to flexibly describe complex layouts without discarding important topological information.
\pyop3 addresses this by introducing a new abstraction for describing data layouts: \emph{axis trees}.
The fundamental characteristics of an axis tree are as follows:

\begin{itemize}
  \item
    An axis tree is a tree of \emph{axis} objects.

  \item
    Each axis object has one or more \emph{axis components}.

  \item
    The axis at the top of the tree is called the \emph{root} axis.

  \item
    \emph{Non-root axes attach to components of their parent axis.}
    That is, each axis has a \emph{parent} consisting of the 2-tuple $(\textnormal{\it parent axis}, \textnormal{\it parent component})$.

  \item
    Both axes and components have a \emph{label}.

  \item
    No ancestors or children of an axis may share the same label.
    Axes in a tree may have the same labels, but only if they do not share a common \emph{path} from root to leaf.

  \item
    Axis component labels must be unique within an axis.

  \item
    Axis components store a size attribute.
\end{itemize}

Axis trees are analogous to the metadata of a \numpy array, or a \pyop2 \pycode{DataSet}: they exist alongside a block of memory and provide the information necessary to interpret it.
Axis trees are especially similar to \numpy arrays in that they both describe multi-dimensional data and accept multi-indices that are transformed into offsets.
Indeed, single-component axes in \pyop3 are equivalent to the axes of a \numpy array, hence the choice of name.
The core difference to these existing abstractions that axis trees bring is the ability to describe more heterogeneous data layouts since axes can \emph{branch}.

\todo[inline]{Make the heading bold (and consistent across examples).}
\begin{example}{Linear axis trees}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{linear_axis_tree_complete.pdf}
  \end{subfigure}
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{linear_data_tree_complete.pdf}
  \end{subfigure}
  \caption{
    Linear axis tree (left) and its resulting data layout (right).
    The axes are labelled $a$, $b$, and $c$ and all have a single component, labelled $x$.
    The red arrows go from parent component to child to show that child axes attach to particular components of the parent.
  }
  \label{fig:linear_axis_tree}
\end{figure}

As a first example to demonstrate axis trees we consider the simplest case: \emph{linear} axis trees.
Linear axis trees are defined as being axis trees where all of the axes have a single component.
They are equivalent to multi-dimensional arrays in \numpy.

An example of a linear axis tree is shown in \cref{fig:linear_axis_tree}.
Consisting of 3 axes labelled $a$, $b$, and $c$, it is equivalent to a \numpy array with shape \pycode{(2, 3, 2)} with axis $a$ of the axis tree matching axis 0 of the \numpy array and so on.
Each axis has a single component, all labelled $x$, with sizes 2, 3, and 2.

Some important features of this axis tree include:

\begin{itemize}
  \item
    The axes have unique labels ($a$, $b$, and $c$).
    Labelling two of the axes $a$, say, would not be allowed.

  \item
    The axis components all have the same label ($x$).
    This is permitted because component labels need only be unique \emph{per axis}.

  \item
    The parent-child relationships of the different axes are as follows:

    \begin{itemize}
      \item Axis $a$ is the root of the tree and so has no parent.
      \item Axis $b$ is the child of component $x$ of axis $a$, hence its parent is the 2-tuple $(a, x)$, sometimes written $a^x$.
      \item Axis $c$ is the child of $(b, x)$.
    \end{itemize}

  \item
    As the axis tree is linear, there is only one path from root to leaf: $\{ a^x, b^x, c^x \}$.
\end{itemize}

\todo[inline]{Put this in a box? Kind of like a footnote or something.}
In \pyop3, axis components are only given labels such that they may be distinguished in a multi-component axis.
For single-component axes this ambiguity is not present and so in future component labels will be omitted in this case for brevity.

\end{example}

\begin{example}{Multi-component axis trees}

\begin{figure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{multi_component_data_tree.pdf}
  \end{subfigure}
  \caption{
    A simple multi-component axis tree (left) and its corresponding data layout (right).
    The distinct components of axis $a$ are coloured red and blue for emphasis.
  }
  \label{fig:multi_component_axis_tree_intro}
\end{figure}

The natural extension to linear axis trees is to consider the case where axes are permitted to have more than one component.
An example of such a multi-component axis tree is shown in \cref{fig:multi_component_axis_tree_intro}.
Compared with the linear case, this axis tree has a few key differences:

\begin{itemize}
  \item
    Axes $b$ and $c$ attach to \emph{different components} of the shared axis $a$.
    The parent of $b$ is $(a, x)$ whilst the parent of $c$ is $(a, y)$.

  \item
    There are now two possible paths from root to leaf: $\{ a^x, b \}$ and $\{ a^y, c \}$ (omitting redundant component labels for axes $b$ and $c$).
\end{itemize}

In terms of data layout, the multiple components of axis $a$ are stored apart from each other, with all entries of component $x$ preceding those of component $y$.

\end{example}

\section{Data structures}

As mentioned above, axis trees are \emph{data layout descriptors} providing a means to interpret blocks of memory.
Actually storing data in \pyop3, therefore, requires new objects that couple axis trees to memory.
Reusing terminology from \pyop2, \pyop3 has \pycode{Globals} (scalars), \pycode{Dats} (vectors), and \pycode{Mats} (matrices).
\pycode{Globals}, being scalars, need no axis trees, \pycode{Dats} require one, and \pycode{Mats} require two (one each for the rows and columns).

Being the most widely used, we will mostly focus of \pycode{Dats} during this thesis.
\pycode{Mats} are more complicated and a discussion of their implementation is deferred to \cref{sec:impl_matrices}.

\section{Alternative data layouts}
\label{sec:axis_tree_alternative_layouts}

\begin{figure}
  \centering
  \begin{subfigure}{.45\textwidth}
    \centering
    \begin{minipage}{.3\textwidth}
      \begin{center}
        \includegraphics{linear_axis_tree.pdf}
      \end{center}
    \end{minipage}
    \begin{minipage}{.6\textwidth}
      \begin{center}
        \includegraphics{linear_data_tree.pdf}
      \end{center}
    \end{minipage}
  \end{subfigure}
  %
  \hspace{1em}
  %
  \begin{subfigure}{.45\textwidth}
    \centering
    \begin{minipage}{.3\textwidth}
      \begin{center}
        \includegraphics{linear_axis_tree_flip.pdf}
      \end{center}
    \end{minipage}
    \begin{minipage}{.6\textwidth}
      \begin{center}
        \includegraphics{linear_data_tree_flip.pdf}
      \end{center}
    \end{minipage}
  \end{subfigure}

  \caption{
    Two equivalent data layouts storing the same information.
    With the original axis tree (left) axis $c$ is `innermost', with unit stride, whilst for the transformed tree (right) this is axis $a$.
  }
  \label{fig:linear_axis_tree_flip}
\end{figure}

By relying on labels to identify axes in an axis tree, it is straightforward to express alternative layouts for the same data - a desirable characteristic for mesh stencil models (\cref{sec:intro_data_layout_flex}) - simply by reordering the axes in the tree.
For example, \cref{fig:linear_axis_tree_flip} shows two equivalent axis trees with differently ordered axes.
By leaving the axes themselves unchanged, and only switching their order, the semantics of the layout are preserved even though the access patterns are changed.

In order to further accomodate this behaviour, \pyop3 is careful designed to avoid making assumptions about the ordering of axes.
For instance, paths, an essential component to many algorithms, are represented as unordered \emph{sets}, rather than lists.
For \cref{fig:linear_axis_tree_flip}, this means that the paths from root to leaf $\{ a, b, c \}$ and $\{ b, c, a \}$ are exactly the same.
By avoiding assumptions about axis ordering, a user can create a data layout using any axis ordering they choose, and the rest of the code will continue to work without modification.

\section{Ragged axis trees}
\label{sec:ragged_axis_trees}

\begin{figure}
  \centering
  \begin{minipage}{.35\textwidth}
    \begin{center}
      \includegraphics{ragged_axis_tree.pdf}
    \end{center}
  \end{minipage}
  %
  \begin{minipage}{.4\textwidth}
    \begin{center}
      \includegraphics{ragged_data_tree.pdf}
    \end{center}
  \end{minipage}
  %
  \begin{minipage}{.2\textwidth}
    \begin{center}
      \includegraphics{ragged_axis_tree_size.pdf}
    \end{center}
  \end{minipage}
  %
  \caption{
    A ragged axis tree (left) and the resulting data layout (middle).
    The cross in the data layout indicates that no values exist for the multi-index $\{a_0, b_1\}$.
    The smaller axis tree (right) is the axis tree for the size array \pycode{[[1, 0], [2, 1]][?$i_a$?, ?$i_b$?]}.
  }
  \label{fig:ragged_axis_tree}
\end{figure}

Thus far we have only considered data layouts where the axis components have constant sizes.
However, there are circumstances where the size is variable; for instance when representing a map from vertices to their incident edges ($\support(v)$, \cref{sec:dmplex_queries}), as the number of incident edges is not constant for all vertices.
Axis trees describing this sort of structure are described as \emph{ragged}.

Ragged axis trees are created by passing a \pycode{Dat} as the size of the axis component, instead of an integer.
This is shown in \cref{fig:ragged_axis_tree}.
Here, the axis tree has 3 axes labelled $a$, $b$, and $c$.
Axes $a$ and $b$ both have a constant size of 2 but $c$, the innermost axis, has a variable size given by the array \pycode{[[1, 0], [2, 1]][?$i_a$?, ?$i_b$?]}.

The notation used here indicates that the array is linear, with shape \pycode{(2, 2)}, and axis labels $a$ and $b$.
This means that the size of $c$ is effectively determined by the table:

\begin{center}
  \begin{tblr}{|[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] c |[1pt]}
    \hline[1pt]
    $i_a$ & $i_b$ & $\textnormal{size}(i_a, i_b)$ \\
    \hline[1pt]
    0 & 0 & 1 \\
    \hline
    0 & 1 & 0 \\
    \hline
    1 & 0 & 2 \\
    \hline
    1 & 1 & 1 \\
    \hline[1pt]
  \end{tblr}
\end{center}

\section{Computing offsets}
\label{sec:axis_tree_layouts}

% NOTE: avoid any mention of the post-order traversal - isn't right or useful

\begin{figure}
  \centering

  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{a\}$ & $\textnormal{offset}(i_a) = 6 i_a$ & $\textnormal{offset}(i_a) = 6 i_a$ \\
      $\{a, b\}$ & $\textnormal{offset}(i_b) = 2 i_b$ & $\textnormal{offset}(i_a, i_b) = 6 i_a + 2 i_b$ \\
      $\{a, b, c\}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$ \\
      \hline
    \end{tabular}
  \end{subfigure}
  \caption{
    Partial and full layout functions (bottom) for the different axes of the linear axis tree (top).
  }
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the headers of \numpy arrays (\cref{sec:numpy}) decribe how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses a flat array.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.
In \pyop3, these offset expressions are termed \textit{layout functions}.

Layout functions are computed in two stages:

\begin{enumerate}
  \item
    A layout function is determined per axis component.
    This is termed the \textit{partial layout function}.

  \item
    The \textit{full layout function} is determined by summing partial layout functions down the tree.
\end{enumerate}

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a \numpy array with shape \pycode{(2, 3, 2)} with the \numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $\textrm{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$.

\pyop3 uses pymbolic\footnote{https://documen.tician.de/pymbolic/index.html} to store and manipulate the symbolic expressions.

% should explain in more detail (use example) the difference between partial and full layout functions
% also explain the path!

% Of these, the former stage is by far the most complex and is the one that will be explained in more detail below.
%
% In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.
%
% There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsection{Intermediate algorithm 1: Linear axis trees}

To simplify exposition, we begin bt determining the right layout functions for a simple linear, non-ragged axis tree, such as that shown in \cref{fig:linear_axis_data_tree}.
Since the trees are not ragged no tabulation need occur and the layout functions will simply be weighted sums of the input indices.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2}
        def collect_layouts_linear(axis: Axis):
          layouts = {}

          # partial layout for the current axis
          if has_subaxis(axis):
            subaxis = get_subaxis(axis)
            step = get_axis_size(subaxis)
          else:
            step = 1
          layouts[axis] = AxisVar(axis.label) * step?\label{code:linear_layout}?

          # traverse subtree
          if has_subaxis(axis): 
            subaxis = get_subaxis(axis)
            sublayouts = collect_layouts_linear(subaxis)?\label{code:linear_sublayouts}?
            layouts.update(sublayouts)

          return layouts
      \end{pyalg2}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the partial layout functions of a linear, non-ragged axis tree such as that shown in \cref{fig:linear_axis_data_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:collect_layouts_linear}
\end{algorithm}

Pseudocode for determining the right partial layout functions for such an axis tree is shown in \cref{alg:collect_layouts_linear}.
The function \pycode{collect_layouts_linear} is invoked passing the root (top) axis of the axis tree, which is then traversed in a post-order fashion with subaxes handled first (line \ref{code:linear_sublayouts}).
For each axis in the tree, the partial layout function is simply the symbolic expression \pycode{AxisVar(axis.label) * step} (line \ref{code:linear_layout}).
\pycode{AxisVar(axis.label)} is equivalent to the indices $i_a$, $i_b$ or $i_c$ found in \cref{fig:linear_axis_data_tree}, and \pycode{step} is an integer storing the size of all the subaxes, and hence the stride of the current axis.
If there are no subaxes then the \pycode{step} must be 1.

\subsection{Intermediate algorithm 2: Multi-component axis trees}
\label{sec:layout_alg_multi_component}

% TODO: Explain how the path differs here, has superscript.

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree.pdf}
    \caption{A simple multi-component axis tree.}
    \label{fig:multi_component_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{multi_component_data_tree.pdf}
    \caption{Data layout for the axis tree shown in \cref{fig:multi_component_axis_tree}.}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{ a^x \}$ & $\textnormal{offset}(i_a) = 3 i_a$ & $\textnormal{offset}(i_a) = 3 i_a$ \\
      \hline
      $\{ a^x, b \}$ & $\textnormal{offset}(i_b) = i_b$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ \\
      \hline
      $\{ a^y \}$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ \\
      \hline
      $\{ a^y, c \}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_c) = 2 i_a + 6 + i_c$ \\
      \hline
    \end{tabular}
    \caption{
      The layout functions.
    }
    \label{fig:multi_component_layouts}
  \end{subfigure}

  \caption{Partial and full layout functions for a multi-component axis tree.}
  \label{fig:multi_component_axis_tree_all}
\end{figure}

% don't say "things"
When multi-component axis trees are introduced, a number of things change:

\begin{itemize}
  \item
    There is no longer a single partial layout function per axis, instead there is a partial layout function \textit{per axis component}.

  \item
    In addition to having weighted sums of indices, one can now also have \textit{scalar offsets} between axis components.
\end{itemize}

These modifications are demonstrated in \cref{fig:multi_component_axis_tree_all}.
The axis $a$ has two components, $x$ and $y$, that are shown in red and blue.
All elements of the $x$ component are stored contiguously before those of $y$.

If we inspect the layout functions in \cref{fig:multi_component_layouts} we can see that the paths are now partitioned by component: $a^x$ and $a^y$ are considered distinct.
Further, a scalar offset of 6 is needed for the $a^y$ partial layout function.
This is included so the expression can step over all the preceding elements of $a^x$.

For simplicity we omit component labels for the single-component axes $b$ and $c$.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      % FIXME: not right anymore
      \begin{pyalg2*}{highlightlines={5,12-13,19-20}}
        def collect_layouts_multi_component(axis: Axis):
          layouts = {}

          # partial layouts for the current axis
          start = 0
          for component in axis.components:?\label{code:mc_loop1}?
            if has_subaxis(axis, component):
              subaxis = get_subaxis(axis, component)
              step = get_axis_size(subaxis)
            else:
              step = 1
              layouts[(axis, component)] = AxisVar(axis.label) * step + start?\label{code:mc_layout_store}?
            start += step

          # traverse subtree
          for component in axis.components:?\label{code:mc_loop1}?
            if has_subaxis(axis, component): 
              subaxis = get_subaxis(axis, component)
              sublayouts = collect_layouts_multi_component(subaxis)
              layouts.update(sublayouts)

          return layouts
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
    Some lines are highlighted to emphasise differences with \cref{alg:collect_layouts_linear}.
  }
  \label{alg:collect_layouts_multi_component}
\end{algorithm}

Regarding the previous algorithm for determining layout functions (\cref{alg:collect_layouts_linear}), a number of changes are now required to capture this additional information (\cref{alg:collect_layouts_multi_component}):

\begin{itemize}
  \item
    The post-order traversal must now be over \textit{per component} subaxes.
    This means that additional loops over \pycode{axis.components} are required (lines~\ref{code:mc_loop1},~\ref{code:mc_loop2}) and that \pycode{has_subaxis()} and \pycode{get_subaxis()} now need to pass both \pycode{axis} and \pycode{component}.

  \item
    Similarly, since separate partial layouts are required for each axis component, the \pycode{layouts} dictionary now stores values per \pycode{(axis, component)} pair (line~\ref{code:mc_layout_store}).

  \item
    The scalar offset between axis components is tracked by the \pycode{start} variable and the per-component expression is now \pycode{AxisVar(axis.label) * step + start} (line~\ref{code:mc_layout_store}).
\end{itemize}

\subsection{Final algorithm: Including ragged axis trees}
\label{sec:layout_alg_ragged}

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \hline
      $\{a\}$ & $\textnormal{offset}(i_a) = \pycode{[0, 1][?$i_a$?]}$ \\
      \hline
      $\{b\}$ & $\textnormal{offset}(i_a, i_b) = \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]}$ \\
      \hline
      $\{c\}$ & $\textnormal{offset}(i_c) = i_c$ \\
      \hline
      \hline
      $\{a, b, c\}$ & $\textnormal{offset}(i_a,i_b,i_c) = \pycode{[0, 1][?$i_a$?]} + \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]} + i_c$ \\
      \hline
    \end{tabular}
  \end{subfigure}

  \caption{Data layout and tabulated layout functions for a ragged axis tree.}
  \label{fig:ragged_axis_tree_layout}
\end{figure}

% NOTE: mention that ragged + multi-component is not yet supported!

For ragged axis trees a new approach is needed.
Since the strides between entries are no longer uniform it is no longer sufficient for layout functions to be expressed as a simple affine function, and instead the offsets must be tabulated into some array.
This is demonstrated in \cref{fig:ragged_axis_tree_layout}.
Both axes $a$ and $b$ have non-uniform strides resulting in offset functions $\pycode{[0, 1][?$i_a$?]}$ and $\pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]}$ respectively.
Axis $c$, being the leaf axis, has a uniform stride of 1 and so the layout function is trivial.
As before the complete layout function is the sum of the partial functions and is given by

\begin{equation*}
  \textnormal{offset}(i_a,i_b,i_c) = \pycode{[0, 1][?$i_a$?]} + \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]} + i_c,
\end{equation*}

which is equivalent to the table

\begin{center}
  \begin{tblr}{|[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] c |[1pt]}
    \hline[1pt]
    $i_a$ & $i_b$ & $i_c$ & $\textnormal{offset}(i_a, i_b, i_c)$ \\
    \hline[1pt]
    0 & 0 & 0 & 0 \\
    \hline
    1 & 0 & 0 & 1 \\
    \hline
    1 & 0 & 1 & 2 \\
    \hline
    1 & 1 & 0 & 3 \\
    \hline[1pt]
  \end{tblr}
\end{center}

For axis $b$, it is important to note that its stride depends upon both the indices $i_a$ and $i_b$, and hence its partial layout is 2 dimensional.
Since axis $b$ relies on axis $a$ for tabulation we say that axis $a$ is a \textit{dependent} axis for axis $b$.

% TODO: highlight the right lines
\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2*}{highlightlines={6,11}}
        def collect_layouts_ragged(axis: Axis):
          layouts = {}

          # partial layouts for the current axis
          for component in axis.components:
            if has_constant_step(axis, component):?\label{code:has_constant_step}?
              # affine case, see earlier algorithms
              ...
            else:
              # axis component has a ragged subaxis
              layouts[(axis, component)] = tabulate_offsets(axis, component)?\label{code:call_tabulate_offsets}?

          # traverse subtree
          for component in axis.components:
            if has_subaxis(axis, component): 
              subaxis = get_subaxis(axis, component)
              sublayouts = collect_layouts_ragged(subaxis)
              layouts.update(sublayouts)

          return layouts
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may be ragged.
  }
  \label{alg:collect_layouts_ragged}
\end{algorithm}

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2*}{highlightlines={}}
        def tabulate_offsets(axis: Axis, component: AxisComponent):
          dependent_axes = collect_dependent_axes(axis, component)?\label{code:collect_dependent_axes}?

          offset_axes = AxisTree.from_iterable([dependent_axes, axis])?\label{code:offset_axes}?
          offset_dat = Dat(offset_axes\label{code:offset_dat})

          # perform the tabulation
          for dep_indices in dependent_axes.iter():?\label{code:loop_dependent_axes}?
            offset = 0
            for axis_indices in axis.iter():?\label{code:loop_current_axis}?
              indices = dep_indices | axis_indices

              offset_dat.set_value(indices, offset)
              offset += step_size(axis, component, indices)

          return offset_dat
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Code that tabulates the offsets for an axis with non-uniform strides.
  }
  \label{alg:tabulate_offsets}
\end{algorithm}

To determine the partial layouts for such a tree we must make a handful of changes to \cref{alg:collect_layouts_multi_component}.
Shown in \cref{alg:collect_layouts_ragged}, these are:

\begin{itemize}
  \item
    An additional check is added to distinguish between the affine case (described in \cref{sec:layout_alg_multi_component}) and the case with non-uniform strides (line~\ref{code:has_constant_step}).

  \item
    If non-uniform strides are detected then an array containing the correct offsets is tabulated (line~\ref{code:call_tabulate_offsets}).
\end{itemize}

To tabulate the offsets an additional function \pycode{tabulate_offsets} is used.
Summarised in \cref{alg:tabulate_offsets} it does the following:

\begin{enumerate}
  \item
    First the dependent axes are discovered (line~\ref{code:collect_dependent_axes}).
    These are the additional axes that must be walked over to tabulate the offsets (line~\ref{code:loop_dependent_axes}).
    Dependent axes are only required in cases with more complex ragged structures such as with axis $b$ in \cref{fig:ragged_axis_tree_layout}.

  \item
    Then, a new array, or \pycode{Dat} (\cref{sec:data_structures}), is constructed to store the offsets (lines~\ref{code:offset_axes} and~\ref{code:offset_dat}) .
    The required axis tree (\pycode{offset_axes}) is linear and is the concatenation of the dependent axes with the current axis.
    In the example of \cref{fig:ragged_axis_tree_layout} this produces an offset axis tree just containing axis $a$ when tabulating axis $a$, and one containing both axes $a$ and $b$ when tabulating axis $b$.

  \item
    Lastly, both the dependent axes and current axis are looped over, incrementing and storing the offset in \pycode{offset_dat} each time.
    This process is equivalent to that used by a PETSc \ccode{PetscSection} during \ccode{PetscSectionSetUp()} (\cref{alg:petsc_section_tabulate}).
\end{enumerate}

It is significant to note that the loops over axes using the \pycode{iter()} method (lines~\ref{code:loop_dependent_axes} and~\ref{code:loop_current_axis}) are implemented in Python and hence are relatively slow to evaluate.
It is our present assumption that such setup costs are amortized over the duration of the program, though future work to transition to an implementation in Cython or C is likely.

\end{document}
