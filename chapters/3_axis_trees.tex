\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Describing mesh-like data layouts}
\label{chapter:axis_trees}

As we have seen thus far, existing software abstractions for mesh-like data layouts are limited by their ability to describe complex layouts without discarding important topological information.
\pyop3 addresses this by introducing a new data layout abstraction: \textit{axis trees}.

\section{Motivation} % maybe this is not a section, but just the intro? same structure should be used for indexing chapter.

% sv element stuff
\begin{figure}
  \centering
  \includegraphics{sv_data_tree.pdf}
  \caption{Tree-like representation of the data layout shown in \cref{fig:scott_vogelius_dof_layout}.}
  \label{fig:sv_data_tree}
\end{figure}

If we again consider the data layout for the Scott-Vogelius element (\cref{fig:scott_vogelius_dof_layout}) it can be observed that the data layout naturally decomposes into a tree-like structure.
This is shown in \cref{fig:sv_data_tree}.

\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{mixed_axis_tree.pdf}
    \caption{
      Abstract representation of the axis tree.
      For simplicity the component labels for the \textit{dof} subaxes have been omitted.
    }
    \label{fig:axis_tree_abstract}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{minipage}{.8\textwidth}
      % TODO: Use some predefined env
      \begin{minted}[frame=single,autogobble]{python}
        mesh_axis = Axis({"vertex": 3, "edge": 3, "cell": 1}, "mesh")
        axes = AxisTree.from_nest({
          Axis({"Vh": 1, "Qh": 1}, "space"): [
            {
              mesh_axis: [  # Vh space
                {Axis(1, "node"): Axis(2, "component")},  # vertices
                {Axis(2, "node"): Axis(2, "component")},  # edges
                {Axis(1, "node"): Axis(2, "component")},  # cells
              ]
            },
            {
              mesh_axis: [  # Qh space
                Axis(0, "node"),  # vertices
                Axis(0, "node"),  # edges
                Axis(6, "node"),  # cells
              ]
            },
          ]
        })
      \end{minted}
    \end{minipage}
    \caption{
      \pyop3 code that constructs the axis tree shown in \cref{fig:axis_tree_abstract}.
      The tree structure is represented by a nested collection of Python dictionaries and lists.
      Axis components are implicitly constructed by the \pycode{Axis} constructor.
      \pycode{Axis(2, "mylabel")} creates an axis labelled \pycode{"mylabel"} with a single anonymous component of size 2, and \pycode{Axis({"x": 2, "y": 3}, "mylabel")} creates a similarly labelled axis but with two components labelled \pycode{"x"} and \pycode{"y"}.
    }
    \label{fig:axis_tree_code}
  \end{subfigure}
  %
  \caption{
    The axis tree representing the data layout shown in \cref{fig:sv_data_tree}.
  }
  \label{fig:axis_tree}
\end{figure}

\section{Axis trees}
\label{sec:axis_trees}

% Needs more
Using an axis tree, \pyop3 is capable of capturing this structure entirely (\cref{fig:axis_tree}).

\begin{itemize}
  \item
    An axis tree is composed of a hierarchy of \textit{axes}.

  \item
    Each axis has one or more \textit{axis components}.

  \item
    Each axis may either be the \textit{root} axis, or have a \textit{parent} consisting of the 2-tuple (parent axis, parent component).

  \item
    Both axes and components are equipped with a \textit{label}.
    If an axis only has a single component then the component's label may be omitted.

  \item
    With these labels, one can uniquely describe a particular \textit{path} going down the tree from root to leaf.
    To give an example from \cref{fig:two_cell_mesh_lagrange_axis_tree}, one could select the DoFs associated with the edges by passing the path (as a mapping): \pycode{{ "mesh": "edge", "dof": None }}.

  \item
    Axis component labels must be unique within an axis, and axis labels must be unique within each possible path leading from root to leaf.

  \item
    Axis trees are immutable. Applying transformations to an existing tree always returns a new object.
\end{itemize}

\begin{figure}
  \centering
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
  \end{subfigure}
  \caption{
    Data layout (left) and axis tree (right) equivalent to a numpy array with shape \pycode{(2, 3, 2)}.
    The axes have been given the arbitrary labels $a$, $b$ and $c$ that correspond to axes 0, 1 and 2 of the equivalent numpy array respectively.
    Axis component labels have been omitted as there is only a single component per axis and hence there is no ambiguity.
  }
  \label{fig:numpy_axis_tree}
\end{figure}

In the same way as numpy, \pyop3 uses the term \textit{axis} to refer to a particular dimension of an array.
Indeed, it is straightforward to construct an axis tree equivalent to a numpy \pycode{ndarray} (\cref{fig:numpy_axis_tree}).
The axes in such axis trees are only permitted to have a single component, and hence they are referred to as \textit{linear} axis trees.

% put into a bullet-ed list?
Where \pyop3 differs from numpy is the fact that axes are permitted to have more than one component, and hence more than one subaxis.
This enables one to express data layouts resembling DMPlex: all mesh points belong to the same axis but one can distinguish the different entity types by considering them separate axis components.
Mixed function spaces are also natural to express as one-sized multi-component axes, as are vector-valued spaces with a single component subaxis of the correct dimension.
These can all be seen in \cref{fig:axis_tree}.

By default, when constructing an axis with multiple components the components are stored as contiguous blocks with all entries from the first component preceding the second and so on.
This is incompatible with the renumbering data locality optimisation described in \cref{sec:intro_mesh_numbering} and \cref{sec:dmplex_data_layout} and so more is required for that to work.
This is described in \cref{chapter:indexing}.

\section{Alternative data layouts}

\begin{figure}
  \centering
  \includegraphics{sv_swap_axis_tree.pdf}
  \caption{
    Axis tree for the alternative data layout in \cref{fig:scott_vogelius_element_dof_layout_swap}.
  }
  \label{fig:axis_tree_swap}
\end{figure}

One consequence of using axis trees to define data layouts is that it becomes very straightforward to express alternative data layouts for storing the same data simply by reordering the axes in the tree.
Using the example from \cref{sec:intro_mesh_numbering} we can easily build an appropriate axis tree describing this layout (\cref{fig:axis_tree_swap}).
Since the axis labels are preserved by this transformation the rest of the code can still be used unchanged from before (e.g. see \cref{sec:indexing_data_layout_transformations}).

\section{Ragged data layouts}

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
  \end{subfigure}
  %
  \caption{
    A nested ragged data layout (left) and its axis tree representation (right).
    The cross indicates that no values exist for the multi-index $\{a_0, b_1\}$.
  }
  \label{fig:ragged_axis_tree}
\end{figure}

So far we have only considered data layouts where the axis components have constant sizes.
However, there are circumstances where one needs arrays where the inner component sizes depend on the specific outer component.
Such arrays are described as \textit{ragged}.
The need for ragged arrays can occur with a number of DMPlex queries (\cref{sec:dmplex}).
$\support(p)$, with $p$ a vertex, is an example since the number of edges incident upon a vertex is not constant across the mesh.

In \pyop3, ragged axis trees are created by passing an array (specifically a \pycode{Dat}, \cref{sec:data_structures}) as the size of the axis component instead of an integer.
This is shown in \cref{fig:ragged_axis_tree}.
The axis tree has 3 axes, labelled $a$, $b$ and $c$.
Axes $a$ and $b$ both have size 2, but $c$, the innermost axis, has size \pycode{[[1, 0], [2, 1]]}.
This means that the size of $c$ is effectively determined by the table

\begin{center}
  \begin{tblr}{|[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] c |[1pt]}
    \hline[1pt]
    $i_a$ & $i_b$ & $\textnormal{sizes}(i_a, i_b)$ \\
    \hline[1pt]
    0 & 0 & 1 \\
    \hline
    0 & 1 & 0 \\
    \hline
    1 & 0 & 2 \\
    \hline
    1 & 1 & 1 \\
    \hline[1pt]
  \end{tblr}
\end{center}

\section{Computing offsets}
\label{sec:axis_tree_layouts}

% NOTE: avoid any mention of the post-order traversal - isn't right or useful

\begin{figure}
  \centering

  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{a\}$ & $\textnormal{offset}(i_a) = 6 i_a$ & $\textnormal{offset}(i_a) = 6 i_a$ \\
      $\{a, b\}$ & $\textnormal{offset}(i_b) = 2 i_b$ & $\textnormal{offset}(i_a, i_b) = 6 i_a + 2 i_b$ \\
      $\{a, b, c\}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$ \\
      \hline
    \end{tabular}
  \end{subfigure}
  \caption{
    Partial and full layout functions (bottom) for the different axes of the linear axis tree (top).
  }
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the headers of numpy arrays (\cref{sec:numpy}) decribe how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses a flat array.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.
In \pyop3, these offset expressions are termed \textit{layout functions}.

Layout functions are computed in two stages:

\begin{enumerate}
  \item
    A layout function is determined per axis component.
    This is termed the \textit{partial layout function}.

  \item
    The \textit{full layout function} is determined by summing partial layout functions down the tree.
\end{enumerate}

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a numpy array with shape \pycode{(2, 3, 2)} with the numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $\textrm{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$.

\pyop3 uses pymbolic\footnote{https://documen.tician.de/pymbolic/index.html} to store and manipulate the symbolic expressions.

% should explain in more detail (use example) the difference between partial and full layout functions
% also explain the path!

% Of these, the former stage is by far the most complex and is the one that will be explained in more detail below.
%
% In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.
%
% There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsection{Intermediate algorithm 1: Linear axis trees}

To simplify exposition, we begin bt determining the right layout functions for a simple linear, non-ragged axis tree, such as that shown in \cref{fig:linear_axis_data_tree}.
Since the trees are not ragged no tabulation need occur and the layout functions will simply be weighted sums of the input indices.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2}
        def collect_layouts_linear(axis: Axis):
          layouts = {}

          # partial layout for the current axis
          if has_subaxis(axis):
            subaxis = get_subaxis(axis)
            step = get_axis_size(subaxis)
          else:
            step = 1
          layouts[axis] = AxisVar(axis.label) * step?\label{code:linear_layout}?

          # traverse subtree
          if has_subaxis(axis): 
            subaxis = get_subaxis(axis)
            sublayouts = collect_layouts_linear(subaxis)?\label{code:linear_sublayouts}?
            layouts.update(sublayouts)

          return layouts
      \end{pyalg2}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the partial layout functions of a linear, non-ragged axis tree such as that shown in \cref{fig:linear_axis_data_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:collect_layouts_linear}
\end{algorithm}

Pseudocode for determining the right partial layout functions for such an axis tree is shown in \cref{alg:collect_layouts_linear}.
The function \pycode{collect_layouts_linear} is invoked passing the root (top) axis of the axis tree, which is then traversed in a post-order fashion with subaxes handled first (line \ref{code:linear_sublayouts}).
For each axis in the tree, the partial layout function is simply the symbolic expression \pycode{AxisVar(axis.label) * step} (line \ref{code:linear_layout}).
\pycode{AxisVar(axis.label)} is equivalent to the indices $i_a$, $i_b$ or $i_c$ found in \cref{fig:linear_axis_data_tree}, and \pycode{step} is an integer storing the size of all the subaxes, and hence the stride of the current axis.
If there are no subaxes then the \pycode{step} must be 1.

\subsection{Intermediate algorithm 2: Multi-component axis trees}
\label{sec:layout_alg_multi_component}

% TODO: Explain how the path differs here, has superscript.

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree}
    \caption{A simple multi-component axis tree.}
    \label{fig:multi_component_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{multi_component_data_tree}
    \caption{Data layout for the axis tree shown in \cref{fig:multi_component_axis_tree}.}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{ a^x \}$ & $\textnormal{offset}(i_a) = 3 i_a$ & $\textnormal{offset}(i_a) = 3 i_a$ \\
      \hline
      $\{ a^x, b \}$ & $\textnormal{offset}(i_b) = i_b$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ \\
      \hline
      $\{ a^y \}$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ \\
      \hline
      $\{ a^y, c \}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_c) = 2 i_a + 6 + i_c$ \\
      \hline
    \end{tabular}
    \caption{
      The layout functions.
    }
    \label{fig:multi_component_layouts}
  \end{subfigure}

  \caption{Partial and full layout functions for a multi-component axis tree.}
  \label{fig:multi_component_axis_tree_all}
\end{figure}

% don't say "things"
When multi-component axis trees are introduced, a number of things change:

\begin{itemize}
  \item
    There is no longer a single partial layout function per axis, instead there is a partial layout function \textit{per axis component}.

  \item
    In addition to having weighted sums of indices, one can now also have \textit{scalar offsets} between axis components.
\end{itemize}

These modifications are demonstrated in \cref{fig:multi_component_axis_tree_all}.
The axis $a$ has two components, $x$ and $y$, that are shown in red and blue.
All elements of the $x$ component are stored contiguously before those of $y$.

If we inspect the layout functions in \cref{fig:multi_component_layouts} we can see that the paths are now partitioned by component: $a^x$ and $a^y$ are considered distinct.
Further, a scalar offset of 6 is needed for the $a^y$ partial layout function.
This is included so the expression can step over all the preceding elements of $a^x$.

For simplicity we omit component labels for the single-component axes $b$ and $c$.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      % FIXME: not right anymore
      \begin{pyalg2*}{highlightlines={5,12-13,19-20}}
        def collect_layouts_multi_component(axis: Axis):
          layouts = {}

          # partial layouts for the current axis
          start = 0
          for component in axis.components:?\label{code:mc_loop1}?
            if has_subaxis(axis, component):
              subaxis = get_subaxis(axis, component)
              step = get_axis_size(subaxis)
            else:
              step = 1
              layouts[(axis, component)] = AxisVar(axis.label) * step + start?\label{code:mc_layout_store}?
            start += step

          # traverse subtree
          for component in axis.components:?\label{code:mc_loop1}?
            if has_subaxis(axis, component): 
              subaxis = get_subaxis(axis, component)
              sublayouts = collect_layouts_multi_component(subaxis)
              layouts.update(sublayouts)

          return layouts
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
    Some lines are highlighted to emphasise differences with \cref{alg:collect_layouts_linear}.
  }
  \label{alg:collect_layouts_multi_component}
\end{algorithm}

Regarding the previous algorithm for determining layout functions (\cref{alg:collect_layouts_linear}), a number of changes are now required to capture this additional information (\cref{alg:collect_layouts_multi_component}):

\begin{itemize}
  \item
    The post-order traversal must now be over \textit{per component} subaxes.
    This means that additional loops over \pycode{axis.components} are required (lines~\ref{code:mc_loop1},~\ref{code:mc_loop2}) and that \pycode{has_subaxis()} and \pycode{get_subaxis()} now need to pass both \pycode{axis} and \pycode{component}.

  \item
    Similarly, since separate partial layouts are required for each axis component, the \pycode{layouts} dictionary now stores values per \pycode{(axis, component)} pair (line~\ref{code:mc_layout_store}).

  \item
    The scalar offset between axis components is tracked by the \pycode{start} variable and the per-component expression is now \pycode{AxisVar(axis.label) * step + start} (line~\ref{code:mc_layout_store}).
\end{itemize}

\subsection{Final algorithm: Including ragged axis trees}
\label{sec:layout_alg_ragged}

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \hline
      $\{a\}$ & $\textnormal{offset}(i_a) = \pycode{[0, 1][?$i_a$?]}$ \\
      \hline
      $\{b\}$ & $\textnormal{offset}(i_a, i_b) = \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]}$ \\
      \hline
      $\{c\}$ & $\textnormal{offset}(i_c) = i_c$ \\
      \hline
      \hline
      $\{a, b, c\}$ & $\textnormal{offset}(i_a,i_b,i_c) = \pycode{[0, 1][?$i_a$?]} + \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]} + i_c$ \\
      \hline
    \end{tabular}
  \end{subfigure}

  \caption{Data layout and tabulated layout functions for a ragged axis tree.}
  \label{fig:ragged_axis_tree_layout}
\end{figure}

% NOTE: mention that ragged + multi-component is not yet supported!

For ragged axis trees a new approach is needed.
Since the strides between entries are no longer uniform it is no longer sufficient for layout functions to be expressed as a simple affine function, and instead the offsets must be tabulated into some array.
This is demonstrated in \cref{fig:ragged_axis_tree_layout}.
Both axes $a$ and $b$ have non-uniform strides resulting in offset functions $\pycode{[0, 1][?$i_a$?]}$ and $\pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]}$ respectively.
Axis $c$, being the leaf axis, has a uniform stride of 1 and so the layout function is trivial.
As before the complete layout function is the sum of the partial functions and is given by

\begin{equation*}
  \textnormal{offset}(i_a,i_b,i_c) = \pycode{[0, 1][?$i_a$?]} + \pycode{[[0, 1], [0, 2]][?$i_a$?, ?$i_b$?]} + i_c,
\end{equation*}

which is equivalent to the table

\begin{center}
  \begin{tblr}{|[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] X[1.2cm,c] |[1pt] c |[1pt]}
    \hline[1pt]
    $i_a$ & $i_b$ & $i_c$ & $\textnormal{offset}(i_a, i_b, i_c)$ \\
    \hline[1pt]
    0 & 0 & 0 & 0 \\
    \hline
    1 & 0 & 0 & 1 \\
    \hline
    1 & 0 & 1 & 2 \\
    \hline
    1 & 1 & 0 & 3 \\
    \hline[1pt]
  \end{tblr}
\end{center}

For axis $b$, it is important to note that its stride depends upon both the indices $i_a$ and $i_b$, and hence its partial layout is 2 dimensional.
Since axis $b$ relies on axis $a$ for tabulation we say that axis $a$ is a \textit{dependent} axis for axis $b$.

% TODO: describe tabulate_offsets in some way.
% TODO: highlight the right lines
\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2*}{highlightlines={6,11}}
        def collect_layouts_ragged(axis: Axis):
          layouts = {}

          # partial layouts for the current axis
          for component in axis.components:
            if has_constant_step(axis, component):?\label{code:has_constant_step}?
              # affine case, see earlier algorithms
              ...
            else:
              # axis component has a ragged subaxis
              layouts[(axis, component)] = tabulate_offsets(axis, component)?\label{code:call_tabulate_offsets}?

          # traverse subtree
          for component in axis.components:
            if has_subaxis(axis, component): 
              subaxis = get_subaxis(axis, component)
              sublayouts = collect_layouts_ragged(subaxis)
              layouts.update(sublayouts)

          return layouts
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may be ragged.
  }
  \label{alg:collect_layouts_ragged}
\end{algorithm}

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2*}{highlightlines={}}
        def tabulate_offsets(axis: Axis, component: AxisComponent):
          dependent_axes = collect_dependent_axes(axis, component)?\label{code:collect_dependent_axes}?

          offset_axes = AxisTree.from_iterable([dependent_axes, axis])?\label{code:offset_axes}?
          offset_dat = Dat(offset_axes\label{code:offset_dat})

          # perform the tabulation
          for dep_indices in dependent_axes.iter():?\label{code:loop_dependent_axes}?
            offset = 0
            for axis_indices in axis.iter():?\label{code:loop_current_axis}?
              indices = dep_indices | axis_indices

              offset_dat.set_value(indices, offset)
              offset += step_size(axis, component, indices)

          return offset_dat
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Code that tabulates the offsets for an axis with non-uniform strides.
  }
  \label{alg:tabulate_offsets}
\end{algorithm}

To determine the partial layouts for such a tree we must make a handful of changes to \cref{alg:collect_layouts_multi_component}.
Shown in \cref{alg:collect_layouts_ragged}, these are:

\begin{itemize}
  \item
    An additional check is added to distinguish between the affine case (described in \cref{sec:layout_alg_multi_component}) and the case with non-uniform strides (line~\ref{code:has_constant_step}).

  \item
    If non-uniform strides are detected then an array containing the correct offsets is tabulated (line~\ref{code:call_tabulate_offsets}).
\end{itemize}

To tabulate the offsets an additional function \pycode{tabulate_offsets} is used.
Summarised in \cref{alg:tabulate_offsets} it does the following:

\begin{enumerate}
  \item
    First the dependent axes are discovered (line~\ref{code:collect_dependent_axes}).
    These are the additional axes that must be walked over to tabulate the offsets (line~\ref{code:loop_dependent_axes}).
    Dependent axes are only required in cases with more complex ragged structures such as with axis $b$ in \cref{fig:ragged_axis_tree_layout}.

  \item
    Then, a new array, or \pycode{Dat} (\cref{sec:data_structures}), is constructed to store the offsets (lines~\ref{code:offset_axes} and~\ref{code:offset_dat}) .
    The required axis tree (\pycode{offset_axes}) is linear and is the concatenation of the dependent axes with the current axis.
    In the example of \cref{fig:ragged_axis_tree_layout} this produces an offset axis tree just containing axis $a$ when tabulating axis $a$, and one containing both axes $a$ and $b$ when tabulating axis $b$.

  \item
    Lastly, both the dependent axes and current axis are looped over, incrementing and storing the offset in \pycode{offset_dat} each time.
    This process is equivalent to that used by a PETSc \ccode{Section} during \ccode{PetscSectionSetUp()} (\cref{alg:petsc_section_tabulate}).
\end{enumerate}

It is significant to note that the loops over axes using the \pycode{iter()} method (lines~\ref{code:loop_dependent_axes} and~\ref{code:loop_current_axis}) are implemented in Python and hence are relatively slow to evaluate.
It is our present assumption that such setup costs are amortized over the duration of the program, though future work to transition to an implementation in Cython or C is likely.

\end{document}
