\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Describing mesh-like data layouts}
\label{chapter:axis_trees}

As we have seen thus far, existing software abstractions for mesh-like data layouts are limited by their ability to describe complex layouts without discarding important topological information.
\pyop3 addresses this by introducing a new data layout abstraction: \textit{axis trees}.

\section{Axis trees}
\label{sec:axis_trees}

\begin{figure}
  \centering
  \includegraphics{sv_data_tree.pdf}
  \caption{Tree-like representation of the data layout shown in \cref{fig:scott_vogelius_dof_layout}.}
  \label{fig:sv_data_tree}
\end{figure}

If we again consider the data layout for the Scott-Vogelius element (\cref{fig:scott_vogelius_dof_layout}) it can be observed that the data layout naturally decomposes into a tree-like structure.
This is shown in \cref{fig:sv_data_tree}.

% Needs more
Using an axis tree, \pyop3 is capable of capturing this structure entirely (\cref{fig:axis_tree}).

\begin{itemize}
  \item
    An axis tree is composed of a hierarchy of \textit{axes}.

  \item
    Each axis has one or more \textit{axis components}.

  \item
    Each axis may either be the \textit{root} axis, or have a \textit{parent} consisting of the 2-tuple (parent axis, parent component).

  \item
    Both axes and components are equipped with a \textit{label}.
    If an axis only has a single component then the component's label may be omitted.

  \item
    With these labels, one can uniquely describe a particular \textit{path} going down the tree from root to leaf.
    To give an example from \cref{fig:two_cell_mesh_lagrange_axis_tree}, one could select the DoFs associated with the edges by passing the path (as a mapping): \pycode{{ "mesh": "edge", "dof": None }}.

  \item
    Axis component labels must be unique within an axis, and axis labels must be unique within each possible path leading from root to leaf.

  \item
    Axis trees are immutable. Applying transformations to an existing tree always returns a new object.
\end{itemize}

\begin{figure}
  \centering
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
  \end{subfigure}
  \caption{
    Data layout (left) and axis tree (right) equivalent to a numpy array with shape \pycode{(2, 3, 2)}.
    The axes have been given the arbitrary labels $a$, $b$ and $c$ that correspond to axes 0, 1 and 2 of the equivalent numpy array respectively.
    Axis component labels have been omitted as there is only a single component per axis and hence there is no ambiguity.
  }
  \label{fig:numpy_axis_tree}
\end{figure}

In the same way as numpy, \pyop3 uses the term \textit{axis} to refer to a particular dimension of an array.
Indeed, it is straightforward to construct an axis tree equivalent to a numpy \pycode{ndarray} (\cref{fig:numpy_axis_tree}).
The axes in such axis trees are only permitted to have a single component, and hence they are referred to as \textit{linear} axis trees.

\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{mixed_axis_tree.pdf}
    \caption{
      Abstract representation of the axis tree.
      For simplicity the component labels for the \textit{dof} subaxes have been omitted.
    }
    \label{fig:axis_tree_abstract}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{minipage}{.8\textwidth}
      % TODO: Use some predefined env
      \begin{minted}[frame=single,autogobble]{python}
        mesh_axis = Axis({"vertex": 3, "edge": 3, "cell": 1}, "mesh")
        axes = AxisTree.from_nest({
          Axis({"Vh": 1, "Qh": 1}, "space"): [
            {
              mesh_axis: [  # Vh space
                {Axis(1, "node"): Axis(2, "component")},  # vertices
                {Axis(2, "node"): Axis(2, "component")},  # edges
                {Axis(1, "node"): Axis(2, "component")},  # cells
              ]
            },
            {
              mesh_axis: [  # Qh space
                Axis(0, "node"),  # vertices
                Axis(0, "node"),  # edges
                Axis(6, "node"),  # cells
              ]
            },
          ]
        })
      \end{minted}
    \end{minipage}
    \caption{
      \pyop3 code that constructs the axis tree shown in \cref{fig:axis_tree_abstract}.
      The tree structure is represented by a nested collection of Python dictionaries and lists.
      Axis components are implicitly constructed by the \pycode{Axis} constructor.
      \pycode{Axis(2, "mylabel")} creates an axis labelled \pycode{"mylabel"} with a single anonymous component of size 2, and \pycode{Axis({"x": 2, "y": 3}, "mylabel")} creates a similarly labelled axis but with two components labelled \pycode{"x"} and \pycode{"y"}.
    }
    \label{fig:axis_tree_code}
  \end{subfigure}
  %
  \caption{
    The axis tree representing the data layout shown in \cref{fig:sv_data_tree}.
  }
  \label{fig:axis_tree}
\end{figure}

% put into a bullet-ed list?
Where \pyop3 differs from numpy is the fact that axes are permitted to have more than one component, and hence more than one subaxis.
This enables one to express data layouts resembling DMPlex: all mesh points belong to the same axis but one can distinguish the different entity types by considering them separate axis components.
Mixed function spaces are also natural to express as one-sized multi-component axes, as are vector-valued spaces with a single component subaxis of the correct dimension.
These can all be seen in \cref{fig:axis_tree}.

By default, when constructing an axis with multiple components the components are stored as contiguous blocks with all entries from the first component preceding the second and so on.
This is incompatible with the renumbering data locality optimisation described in \cref{sec:intro_mesh_numbering} and \cref{sec:dmplex_data_layout} and so more is required for that to work.
This is described in \cref{chapter:indexing}.

\section{Alternative data layouts}

\begin{figure}
  \centering
  \includegraphics{sv_swap_axis_tree.pdf}
  \caption{
    Axis tree for the alternative data layout in \cref{fig:scott_vogelius_element_dof_layout_swap}.
  }
  \label{fig:axis_tree_swap}
\end{figure}

One consequence of using axis trees to define data layouts is that it becomes very straightforward to express alternative data layouts for storing the same data simply by reordering the axes in the tree.
Using the example from \cref{sec:intro_mesh_numbering} we can easily build an appropriate axis tree describing this layout (\cref{fig:axis_tree_swap}).
Since the axis labels are preserved by this transformation the rest of the code can still be used unchanged from before (e.g. see \cref{sec:indexing_data_layout_transformations}).

\section{Ragged data layouts}

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
  \end{subfigure}
  %
  \caption{
    A nested ragged data layout (left) and its axis tree representation (right).
    The cross indicates that no values exist for the multi-index $\{a_0, b_1\}$.
  }
  \label{fig:ragged_axis_tree}
\end{figure}

So far we have only considered data layouts where the axis components have constant sizes.
However, there are circumstances where one needs arrays where the inner component sizes depend on the specific outer component.
Such arrays are described as \textit{ragged}.
The need for ragged arrays can occur with a number of DMPlex queries (\cref{sec:dmplex}).
$\support(p)$, with $p$ a vertex, is an example since the number of edges incident upon a vertex is not constant across the mesh.

In \pyop3, ragged axis trees are created by passing an array (specifically a \pycode{Dat}, \cref{sec:data_structures}) as the size of the axis component instead of an integer.
This is shown in \cref{fig:ragged_axis_tree}.
The axis tree has 3 axes, labelled $a$, $b$ and $c$.
Axes $a$ and $b$ both have size 2, but $c$, the innermost axis, has size \pycode{[[1, 0], [2, 1]]}.
This means that the size of $c$ is effectively determined by the function

\begin{equation*}
  \textnormal{size}(i_a, i_b) = 
  \begin{cases}
    1 & \textnormal{if}\ i_a = 0\ \textnormal{and}\ i_b = 0, \\
    0 & \textnormal{if}\ i_a = 0\ \textnormal{and}\ i_b = 1, \\
    2 & \textnormal{if}\ i_a = 1\ \textnormal{and}\ i_b = 0, \\
    1 & \textnormal{if}\ i_a = 1\ \textnormal{and}\ i_b = 1.
  \end{cases}
\end{equation*}

The size array here is dependent upon both $i_a$ and $i_b$.
Depending on the labels used for the array it would also be possible to make the size depend on just $i_a$ or $i_b$ separately.

\section{Computing offsets}

\begin{figure}
  \centering

  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{a\}$ & $\textnormal{offset}(i_a) = 6 i_a$ & $\textnormal{offset}(i_a) = 6 i_a$ \\
      $\{a, b\}$ & $\textnormal{offset}(i_b) = 2 i_b$ & $\textnormal{offset}(i_a, i_b) = 6 i_a + 2 i_b$ \\
      $\{a, b, c\}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$ \\
      \hline
    \end{tabular}
  \end{subfigure}
  \caption{
    Partial and full layout functions (bottom) for the different axes of the linear axis tree (top).
  }
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the headers of numpy arrays (\cref{sec:numpy}) decribe how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses a flat array.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.
In \pyop3, these offset expressions are termed \textit{layout functions}.

Layout functions are computed in two stages:

\begin{enumerate}
  \item
    A layout function is determined per axis component.
    This is termed the \textit{partial layout function}.

  \item
    The \textit{full layout function} is determined by summing partial layout functions down the tree.
\end{enumerate}

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a numpy array with shape \pycode{(2, 3, 2)} with the numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $\textrm{offset}(i_a, i_b, i_c) = 6 i_a + 2 i_b + i_c$.

\pyop3 uses pymbolic\footnote{https://documen.tician.de/pymbolic/index.html} to store and manipulate the symbolic expressions.

% should explain in more detail (use example) the difference between partial and full layout functions
% also explain the path!

% Of these, the former stage is by far the most complex and is the one that will be explained in more detail below.
%
% In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.
%
% There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsection{Intermediate algorithm 1: Linear axis trees}

To simplify exposition, we begin bt determining the right layout functions for a simple linear, non-ragged axis tree, such as that shown in \cref{fig:linear_axis_data_tree}.
Since the trees are not ragged no tabulation need occur and the layout functions will simply be weighted sums of the input indices.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2}
        def tabulate_layouts_linear(axis: Axis):
          layouts = {}

          # post-order traversal
          if has_subaxis(axis): 
            subaxis = get_subaxis(axis)
            sublayouts = tabulate_layouts_linear(subaxis)?\label{code:linear_sublayouts}?
            layouts.update(sublayouts)

          # partial layout for the current axis
          if has_subaxis(axis):
            subaxis = get_subaxis(axis)
            step = get_axis_size(subaxis)
          else:
            step = 1
          layouts[axis] = AxisVar(axis.label) * step?\label{code:linear_layout}?

          return layouts
      \end{pyalg2}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the partial layout functions of a linear, non-ragged axis tree such as that shown in \cref{fig:linear_axis_data_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:tabulate_layouts_linear}
\end{algorithm}

Pseudocode for determining the right partial layout functions for such an axis tree is shown in \cref{alg:tabulate_layouts_linear}.
The function \pycode{tabulate_layouts_linear} is invoked passing the root (top) axis of the axis tree, which is then traversed in a post-order fashion with subaxes handled first (line \ref{code:linear_sublayouts}).
For each axis in the tree, the partial layout function is simply the symbolic expression \pycode{AxisVar(axis.label) * step} (line \ref{code:linear_layout}).
\pycode{AxisVar(axis.label)} is equivalent to the indices $i_a$, $i_b$ or $i_c$ found in \cref{fig:linear_axis_data_tree}, and \pycode{step} is an integer storing the size of all the subaxes, and hence the stride of the current axis.
If there are no subaxes then the \pycode{step} must be 1.

\subsection{Intermediate algorithm 2: Multi-component axis trees}
\label{sec:layout_alg_multi_component}

% TODO: Explain how the path differs here, has superscript.

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree}
    \caption{A simple multi-component axis tree.}
    \label{fig:multi_component_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{multi_component_data_tree}
    \caption{Data layout for the axis tree shown in \cref{fig:multi_component_axis_tree}.}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|l|l|l|}
      \hline
      \textbf{Path} & \textbf{Partial layout function} & \textbf{Full layout function} \\
      \hline
      $\{ a^x \}$ & $\textnormal{offset}(i_a) = 3 i_a$ & $\textnormal{offset}(i_a) = 3 i_a$ \\
      \hline
      $\{ a^x, b \}$ & $\textnormal{offset}(i_b) = i_b$ & $\textnormal{offset}(i_a, i_b) = 3 i_a + i_b$ \\
      \hline
      $\{ a^y \}$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ & $\textnormal{offset}(i_a) = 2 i_a + 6$ \\
      \hline
      $\{ a^y, c \}$ & $\textnormal{offset}(i_c) = i_c$ & $\textnormal{offset}(i_a, i_c) = 2 i_a + 6 + i_c$ \\
      \hline
    \end{tabular}
    \caption{
      The layout functions.
    }
    \label{fig:multi_component_layouts}
  \end{subfigure}

  \caption{Partial and full layout functions for a multi-component axis tree.}
  \label{fig:multi_component_axis_tree_all}
\end{figure}

% don't say "things"
When multi-component axis trees are introduced, a number of things change:

\begin{itemize}
  \item
    There is no longer a single partial layout function per axis, instead there is a partial layout function \textit{per axis component}.

  \item
    In addition to having weighted sums of indices, one can now also have \textit{scalar offsets} between axis components.
\end{itemize}

These modifications are demonstrated in \cref{fig:multi_component_axis_tree_all}.
The axis $a$ has two components, $x$ and $y$, that are shown in red and blue.
All elements of the $x$ component are stored contiguously before those of $y$.

If we inspect the layout functions in \cref{fig:multi_component_layouts} we can see that the paths are now partitioned by component: $a^x$ and $a^y$ are considered distinct.
Further, a scalar offset of 6 is needed for the $a^y$ partial layout function.
This is included so the expression can step over all the preceding elements of $a^x$.

For simplicity we omit component labels for the single-component axes $b$ and $c$.

\begin{algorithm}
  \begin{center}
    \begin{minipage}{.9\textwidth}
      \begin{pyalg2*}{highlightlines={5,12-13,19-20}}
        def tabulate_layouts_multi_component(axis: Axis):
          layouts = {}

          # post-order traversal
          for component in axis.components:?\label{code:mc_loop1}?
            if has_subaxis(axis, component): 
              subaxis = get_subaxis(axis, component)
              sublayouts = tabulate_layouts_multi_component(subaxis)
              layouts.update(sublayouts)

          # partial layouts for the current axis
          start = 0
          for component in axis.components:?\label{code:mc_loop2}?
            if has_subaxis(axis, component):
              subaxis = get_subaxis(axis, component)
              step = get_axis_size(subaxis)
            else:
              step = 1
              layouts[(axis, component)] = AxisVar(axis.label) * step + start?\label{code:mc_layout_store}?
            start += step

          return layouts
      \end{pyalg2*}
    \end{minipage}
  \end{center}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
    Some lines are highlighted to emphasise differences with \cref{alg:tabulate_layouts_linear}.
  }
  \label{alg:tabulate_layouts_multi_component}
\end{algorithm}

Regarding the previous algorithm for determining layout functions (\cref{alg:tabulate_layouts_linear}), a number of changes are now required to capture this additional information (\cref{alg:tabulate_layouts_multi_component}):

\begin{itemize}
  \item
    The post-order traversal must now be over \textit{per component} subaxes.
    This means that additional loops over \pycode{axis.components} are required (lines~\ref{code:mc_loop1},~\ref{code:mc_loop2}) and that \pycode{has_subaxis()} and \pycode{get_subaxis()} now need to pass both \pycode{axis} and \pycode{component}.

  \item
    Similarly, since separate partial layouts are required for each axis component, the \pycode{layouts} dictionary now stores values per \pycode{(axis, component)} pair (line~\ref{code:mc_layout_store}).

  \item
    The scalar offset between axis components is tracked by the \pycode{start} variable and the per-component expression is now \pycode{AxisVar(axis.label) * step + start} (line~\ref{code:mc_layout_store}).
\end{itemize}

\subsection{Final algorithm: Including ragged axis trees}
\label{sec:layout_alg_ragged}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
    \caption{TODO}
    \label{fig:ragged_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
    \caption{TODO}
    \label{fig:ragged_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    %
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$a$, $b$, $c$\} & $\pycode{[[0, 1], [1, 3]]}_{i_a,i_b} + i_c$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:ragged_layouts}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:ragged_axis_tree_all}
\end{figure}

% TODO: Once things have been cleaned up, redo this.
\begin{algorithm}
  \begin{minted}[linenos,highlightlines={},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_ragged(axis: Axis):
  layouts = {}

  # post-order traversal
  for component in axis.components:
    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      sublayouts, subtree = tabulate_layouts_ragged(subaxis)
      layouts |= sublayouts

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may be ragged.
  }
  \label{alg:tabulate_layouts_ragged}
\end{algorithm}
\end{document}
