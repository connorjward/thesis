\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Describing mesh-like data layouts}
\label{chapter:axis_trees}

As we have seen thus far, existing software abstractions for mesh-like data layouts are limited by their ability to describe complex layouts without discarding important topological information.
\pyop3 addresses this by introducing a new data layout abstraction: \textit{axis trees}.

\section{Axis trees}
\label{sec:axis_trees}

\begin{figure}
  \centering
  \includegraphics{sv_data_tree.pdf}
  \caption{Tree-like representation of the data layout shown in \cref{fig:scott_vogelius_dof_layout}.}
  \label{fig:sv_data_tree}
\end{figure}

If we again consider the data layout for the Scott-Vogelius element (\cref{fig:scott_vogelius_dof_layout}) it can be observed that the data layout naturally decomposes into a tree-like structure.
This is shown in \cref{fig:sv_data_tree}.

% Needs more
Using an axis tree, \pyop3 is capable of capturing this structure entirely (\cref{fig:axis_tree}).

\begin{itemize}
  \item
    An axis tree is composed of a hierarchy of \textit{axes}.

  \item
    Each axis has one or more \textit{axis components}.

  \item
    Each axis may either be the \textit{root} axis, or have a \textit{parent} consisting of the 2-tuple (parent axis, parent component).

  \item
    Both axes and components are equipped with a \textit{label}.
    If an axis only has a single component then the component's label may be omitted.

  \item
    With these labels, one can uniquely describe a particular \textit{path} going down the tree from root to leaf.
    To give an example from \cref{fig:two_cell_mesh_lagrange_axis_tree}, one could select the DoFs associated with the edges by passing the path (as a mapping): \pycode{{ "mesh": "edge", "dof": None }}.

  \item
    Axis component labels must be unique within an axis, and axis labels must be unique within each possible path leading from root to leaf.

  \item
    Axis trees are immutable. Applying transformations to an existing tree always returns a new object.
\end{itemize}

\begin{figure}
  \centering
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.49\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
  \end{subfigure}
  \caption{
    Data layout (left) and axis tree (right) equivalent to a numpy array with shape \pycode{(2, 3, 2)}.
    The axes have been given the arbitrary labels $a$, $b$ and $c$ that correspond to axes 0, 1 and 2 of the equivalent numpy array respectively.
    Axis component labels have been omitted as there is only a single component per axis and hence there is no ambiguity.
  }
  \label{fig:numpy_axis_tree}
\end{figure}

In the same way as numpy, \pyop3 uses the term \textit{axis} to refer to a particular dimension of an array.
Indeed, it is straightforward to construct an axis tree equivalent to a numpy \pycode{ndarray} (\cref{fig:numpy_axis_tree}).
The axes in such axis trees are only permitted to have a single component, and hence they are referred to as \textit{linear} axis trees.

\begin{figure}
  \centering
  %
  \begin{subfigure}{\textwidth}
    \centering
    \includegraphics{mixed_axis_tree.pdf}
    \caption{
      Abstract representation of the axis tree.
      For simplicity the component labels for the \textit{dof} subaxes have been omitted.
    }
    \label{fig:axis_tree_abstract}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{minipage}{.8\textwidth}
      % TODO: Use some predefined env
      \begin{minted}[frame=single,autogobble]{python}
        mesh_axis = Axis({"vertex": 3, "edge": 3, "cell": 1}, "mesh")
        axes = AxisTree.from_nest({
          Axis({"Vh": 1, "Qh": 1}, "space"): [
            {
              mesh_axis: [  # Vh space
                {Axis(1, "node"): Axis(2, "component")},  # vertices
                {Axis(2, "node"): Axis(2, "component")},  # edges
                {Axis(1, "node"): Axis(2, "component")},  # cells
              ]
            },
            {
              mesh_axis: [  # Qh space
                Axis(0, "node"),  # vertices
                Axis(0, "node"),  # edges
                Axis(6, "node"),  # cells
              ]
            },
          ]
        })
      \end{minted}
    \end{minipage}
    \caption{
      \pyop3 code that constructs the axis tree shown in \cref{fig:axis_tree_abstract}.
      The tree structure is represented by a nested collection of Python dictionaries and lists.
      Axis components are implicitly constructed by the \pycode{Axis} constructor.
      \pycode{Axis(2, "mylabel")} creates an axis labelled \pycode{"mylabel"} with a single anonymous component of size 2, and \pycode{Axis({"x": 2, "y": 3}, "mylabel")} creates a similarly labelled axis but with two components labelled \pycode{"x"} and \pycode{"y"}.
    }
    \label{fig:axis_tree_code}
  \end{subfigure}
  %
  \caption{
    The axis tree representing the data layout shown in \cref{fig:sv_data_tree}.
  }
  \label{fig:axis_tree}
\end{figure}

% put into a bullet-ed list?
Where \pyop3 differs from numpy is the fact that axes are permitted to have more than one component, and hence more than one subaxis.
This enables one to express data layouts resembling DMPlex: all mesh points belong to the same axis but one can distinguish the different entity types by considering them separate axis components.
Mixed function spaces are also natural to express as one-sized multi-component axes, as are vector-valued spaces with a single component subaxis of the correct dimension.
These can all be seen in \cref{fig:axis_tree}.

By default, when constructing an axis with multiple components the components are stored as contiguous blocks with all entries from the first component preceding the second and so on.
This is incompatible with the renumbering data locality optimisation described in \cref{sec:intro_mesh_numbering} and \cref{sec:dmplex_data_layout} and so more is required for that to work.
This is described in \cref{chapter:indexing}.

\section{Alternative data layouts}

\begin{figure}
  \centering
  \includegraphics{sv_swap_axis_tree.pdf}
  \caption{
    Axis tree for the alternative data layout in \cref{fig:scott_vogelius_element_dof_layout_swap}.
  }
  \label{fig:axis_tree_swap}
\end{figure}

One consequence of using axis trees to define data layouts is that it becomes very straightforward to express alternative data layouts for storing the same data simply by reordering the axes in the tree.
Using the example from \cref{sec:intro_mesh_numbering} we can easily build an appropriate axis tree describing this layout (\cref{fig:axis_tree_swap}).
Since the axis labels are preserved by this transformation the rest of the code can still be used unchanged from before (e.g. see \cref{sec:indexing_data_layout_transformations}).

\section{Ragged data layouts}

\begin{figure}
  \centering
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
  \end{subfigure}
  \begin{subfigure}{.4\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
  \end{subfigure}
  %
  \caption{
    A nested ragged data layout (left) and its axis tree representation (right).
    The cross indicates that no values exist for the multi-index $\{a_0, b_1\}$.
  }
  \label{fig:ragged_axis_tree}
\end{figure}

So far we have only considered data layouts where the axis components have constant sizes.
However, there are circumstances where one needs arrays where the inner component sizes depend on the specific outer component.
Such arrays are described as \textit{ragged}.
The need for ragged arrays can occur with a number of DMPlex queries (\cref{sec:dmplex}).
$\support(p)$, with $p$ a vertex, is an example since the number of edges incident upon a vertex is not constant across the mesh.

In \pyop3, ragged axis trees are created by passing an array (specifically a \pycode{Dat}, \cref{sec:data_structures}) as the size of the axis component instead of an integer.
This is shown in \cref{fig:ragged_axis_tree}.
The axis tree has 3 axes, labelled $a$, $b$ and $c$.
Axes $a$ and $b$ both have size 2, but $c$, the innermost axis, has size \pycode{[[1, 0], [2, 1]]}.
This means that the size of $c$ is effectively determined by the function

\begin{equation*}
  \textnormal{size}(i_a, i_b) = 
  \begin{cases}
    1 & \textnormal{if}\ i_a = 0\ \textnormal{and}\ i_b = 0, \\
    0 & \textnormal{if}\ i_a = 0\ \textnormal{and}\ i_b = 1, \\
    2 & \textnormal{if}\ i_a = 1\ \textnormal{and}\ i_b = 0, \\
    1 & \textnormal{if}\ i_a = 1\ \textnormal{and}\ i_b = 1.
  \end{cases}
\end{equation*}

The size array here is dependent upon both $i_a$ and $i_b$.
Depending on the labels used for the array it would also be possible to make the size depend on just $i_a$ or $i_b$ separately.

\section{Computing offsets}

\begin{figure}
  \centering
  %
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{linear_axis_tree.pdf}
    \caption{TODO}
    \label{fig:linear_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{linear_data_tree.pdf}
    \caption{TODO}
    \label{fig:linear_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$a$, $b$, $c$\} & $6 i_a + 2 i_b + i_c$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:linear_layouts}
  \end{subfigure}
  \caption{TODO}
  \label{fig:linear_axis_data_tree}
\end{figure}

In the same way that the headers of numpy arrays (\cref{sec:numpy}) decribe how to stride over a flat array, axis trees are simply data layout descriptors that declare how one accesses a flat array.
It is the job of the axis tree to provide the right expression that can be evaluated giving the correct offset into the flat array.
In \pyop3, these offset expressions are termed \textit{layout functions}.

% 5/7 this is where I got to

To give a simple example, consider the axis tree and corresponding data layout shown in \cref{fig:linear_axis_data_tree}.
The tree shown here is equivalent to a numpy array with shape \pycode{(2, 3, 2)} with the numpy axes 0, 1 and 2 given the labels \textit{a}, \textit{b} and \textit{c} respectively.
Given a multi-index of the form $(i_a, i_b, i_c)$ the correct offset into the array may be calculated with the layout function $6 i_a + 2 i_b + i_c$.

Layout functions, expressed in the symbolic maths package \textit{pymbolic}\footnote{https://documen.tician.de/pymbolic/index.html}, may either be evaluated given a set of indices or used during code generation.


\subsection{The layout algorithm, step by step}

The algorithm can be deconstructed into two stages:
\begin{enumerate}
  \item
    Determine the right expression for describing the layout of each axis component separately.
    For the linear axis tree shown in \cref{fig:linear_axis_data_tree} this corresponds to determining the expressions $6 i_a$, $2 i_b$ and $i_c$.
  \item
    Add the component-wise layout expressions together.
\end{enumerate}
Of these, the former stage is by far the most complex and is the one that will be explained in more detail below.

In the following we will incrementally describe the algorithm for determining the right layout function for a given axis tree.

There are additional considerations in parallel that are discussed later in \cref{chapter:parallel}.

\subsubsection{Linear axis trees}

\begin{algorithm}
  \begin{minted}[linenos]{python}
def tabulate_layouts_linear(axis: Axis):
  layouts = {}

  # post-order traversal
  if has_subaxis(axis): 
    subaxis = get_subaxis(axis)
    layouts |= tabulate_layouts_linear(subaxis)

  # layout expression for this axis
  if has_subaxis(axis):
    step = get_subaxis_size(axis)
  else:
    step = 1
  layouts[axis] = AxisVar(axis) * step

  return layouts
  \end{minted}
  %
  \caption{
    Algorithm for computing the layout functions of a linear (single component) axis tree such as that shown in \cref{fig:linear_axis_tree}.
    The function is initially invoked by passing the root axis of the tree.
  }
  \label{alg:tabulate_layouts_linear}
\end{algorithm}

We begin our exposition with the simplest possible case: ``linear" axis trees.
A ``linear" tree means that the axes in the tree are restricted to be single component.
Such trees are directly equivalent to numpy-like N-dimensional arrays or \textit{tensor} objects in many domain-specific programming languages.
An example of such a tree and data layout is shown in \cref{fig:linear_axis_data_tree}.

Pseudocode for determining the right layout function for a linear axis tree is shown in \cref{alg:tabulate_layouts_linear}.
The axis tree is traversed in a post-order fashion with subaxes handled first (the reason for this is made clear in \cref{sec:layout_alg_ragged}).
At each axis, since we only require affine expressions, the layout function is simply the symbolic expression \pycode{AxisVar(axis) * step}, where \pycode{AxisVar(axis)} is a pymbolic \pycode{Variable} object and step is an integer corresponding to the size of the subtree as seen from that axis.

\subsubsection{Multi-component axis trees}
\label{sec:layout_alg_multi_component}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{multi_component_axis_tree}
    \caption{TODO}
    \label{fig:multi_component_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.5\textwidth}
    \centering
    \includegraphics{multi_component_data_tree}
    \caption{TODO}
    \label{fig:multi_component_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$(a, x)$, $b$\} & $3 i_a + i_b$ \\
      \hline
      \{$(a, y)$, $c$\} & $2 i_a + i_c + 6$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:multi_component_layouts}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:multi_component_axis_tree_all}
\end{figure}

\begin{algorithm}
  \begin{minted}[linenos,highlightlines={5-7,11-12,17-18},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_multi_component(axis: Axis):
  layouts = {}

  # post-order traversal
?\tikzmark{a}?  for component in axis.components:
?\tikzmark{b}?    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      layouts |= tabulate_layouts_multi_component(subaxis)

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  % https://tex.stackexchange.com/questions/287549/is-it-possible-to-use-tikzmark-inside-minted
  \begin{tikzpicture}[remember picture]
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (alabel) at ($(pic cs:a)+(\textwidth+12,.1)$) {A};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (blabel) at ($(pic cs:b)+(\textwidth+12,-.1)$) {B};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (clabel) at ($(pic cs:c)+(\textwidth+12,-.1)$) {C};
    % \node [circle,overlay,fill=white,draw=black,minimum width=12pt,inner sep=0,font=\footnotesize,anchor=center,align=center] (dlabel) at ($(pic cs:d)+(\textwidth+12,-.1)$) {D};

    % alternative with braces, unsure which is better
    % \coordinate (alabelbottom) at ($(pic cs:a)+(\textwidth,-4pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (alabelbottom) -- node [right=10pt] {A} ++ (0,13pt);
    %
    % \coordinate (blabelbottom) at ($(pic cs:b)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (blabelbottom) -- node [right=10pt] {B} ++ (0,25pt);
    %
    % \coordinate (clabelbottom) at ($(pic cs:c)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (clabelbottom) -- node [right=10pt] {C} ++ (0,25pt);
    %
    % \coordinate (dlabelbottom) at ($(pic cs:d)+(\textwidth,-16pt)$);
    % \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (dlabelbottom) -- node [right=10pt] {D} ++ (0,25pt);

    \coordinate (alabeltop) at ($(pic cs:a)+(\textwidth,8pt)$);
    \coordinate (alabelbottom) at ($(pic cs:b)+(\textwidth,-16pt)$);
    \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (alabelbottom) -- node [right=10pt] {A} (alabeltop);

    \coordinate (blabeltop) at ($(pic cs:c)+(\textwidth,8pt)$);
    \coordinate (blabelbottom) at ($(pic cs:d)+(\textwidth,-16pt)$);
    \draw[overlay,decoration={brace,mirror,raise=5pt,amplitude=5pt},decorate,line width=.8pt] (blabelbottom) -- node [right=10pt] {B} (blabeltop);
  \end{tikzpicture}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may have multiple components.
  }
  \label{alg:tabulate_layouts_multi_component}
\end{algorithm}

When multi-component axis trees are introduced, a number of things change:
First, there are now multiple layout functions per axis.
This is one per \pycode{(axis, component)} pair.
Second, the affine indexing used in the linear case above must now also include offsets.

This is shown in \cref{fig:multi_component_axis_tree_all}.
The root axis of the axis tree now has two components, given the labels $x$ and $y$, each with their own subaxis (labelled $b$ and $c$).
The layouts of the $(a, x)$ part of the tree are effectively unchanged from the linear case, but the $y$ component of axis $a$ now clearly carries an offset.
This is shown in the layout functions in \cref{fig:multi_component_layouts}.

The modifications from \cref{alg:tabulate_layouts_linear} required to determine the right layout function for a multi-component axis tree are relatively straightforward.
The modified algorithm is shown in \cref{alg:tabulate_layouts_multi_component} with the core changes labelled and highlighted in red.
These core changes are:
\begin{itemize}
  \item[\textbf{A}] The post-order traversal must now be over \textit{per-component} subaxes, so a loop over axis components is required.
  \item[\textbf{B}] The layout functions are now stored per \pycode{(axis, component)} pair, and an additional offset, named \pycode{start}, is added.
\end{itemize}

\subsubsection{Ragged axis trees}
\label{sec:layout_alg_ragged}

\begin{figure}
  \centering
  \begin{subfigure}{.3\textwidth}
    \centering
    \includegraphics{ragged_axis_tree.pdf}
    \caption{TODO}
    \label{fig:ragged_axis_tree}
  \end{subfigure}
  %
  \begin{subfigure}{.58\textwidth}
    \centering
    \includegraphics{ragged_data_tree.pdf}
    \caption{TODO}
    \label{fig:ragged_data_tree}
  \end{subfigure}

  \vspace{1em}

  \begin{subfigure}{\textwidth}
    \centering
    %
    \begin{tabular}{|c|c|}
      \hline
      \textbf{Path} & \textbf{Layout function} \\
      \hline
      \{$a$, $b$, $c$\} & $\pycode{[[0, 1], [1, 3]]}_{i_a,i_b} + i_c$ \\
      \hline
    \end{tabular}
    \caption{TODO}
    \label{fig:ragged_layouts}
  \end{subfigure}
  %
  \caption{TODO}
  \label{fig:ragged_axis_tree_all}
\end{figure}

% TODO: Once things have been cleaned up, redo this.
\begin{algorithm}
  \begin{minted}[linenos,highlightlines={},highlightcolor=red!30,escapeinside=??]{python}
def tabulate_layouts_ragged(axis: Axis):
  layouts = {}

  # post-order traversal
  for component in axis.components:
    if has_subaxis(axis, component): 
      subaxis = get_subaxis(axis, component)
      sublayouts, subtree = tabulate_layouts_ragged(subaxis)
      layouts |= sublayouts

  # layout expressions for this axis
?\tikzmark{c}?  start = 0
  for component in axis.components:
    if has_subaxis(axis, component):
      step = get_subaxis_size(axis, component)
    else:
      step = 1
?\tikzmark{d}?    layouts[(axis, component)] = AxisVar(axis) * step + start
    start += step

  return layouts
  \end{minted}

  \caption{
    Algorithm for computing the layout functions of an axis tree where any of the contained axes may be ragged.
  }
  \label{alg:tabulate_layouts_ragged}
\end{algorithm}
\end{document}
