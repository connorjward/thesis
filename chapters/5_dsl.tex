\documentclass[thesis]{subfiles}

\begin{document}

\chapter{The execution model}
\label{chapter:execution_model}

Thus far we have established a new abstraction for mesh-like data structures, and an approach for symbolically representing smaller ``packed" parts of them.
In order for \pyop3 to be a usable library, rather than just an interesting abstraction to consider, three problems remain:

\begin{itemize}
  \item How are the actual data structures stored in memory?
  \item How does one express operations to be executed?
  \item How are these operations executed?
\end{itemize}

These questions will be answered in this chapter, giving us a fully capable, serial-only, \pyop3 library.

\section{Data structures}
\label{sec:data_structures}

Thus far we have only discussed the \textit{specification} of how data is stored in \pyop3 and not the actual implementation.
For continuum mechanics problems one typically needs to have representations for scalars, vectors and matrices.
In \pyop3, recycling the terminology from \pyop2, we call scalars \pycode{Globals}, vectors \pycode{Dats} and matrices \pycode{Mats}.
All of these data structures work in parallel, and their parallel implementation is deferred to \cref{chapter:parallel}.

\subsection{Scalars (\pycode{Globals})}

\pycode{Globals} are the simplest of \pyop3's data structures.
They wrap a single scalar value, which may be of any data type (e.g. \pycode{int32}, \pycode{float64}, \pycode{complex128}) and thus have a trivial data layout, hence they have no need for axis trees.
It is not valid to index into a \pycode{Global} (\cref{chapter:indexing}).

\subsection{Vectors (\pycode{Dats})}

Thus far, all of the data structures that we have encountered would be stored as \pycode{Dats}.
\pycode{Dats} are constructed with a single axis tree that provides the information necessary to address the underlying flat array that carries the data.
Having a single axis tree, \pycode{Dats} may be indexed using a single index (\cref{chapter:indexing}).

Currently \pycode{Dats} use numpy arrays as the underlying data storage mechanism, but we intend to permit further array types to enable targeting accelerator architectures like CUDA GPUs.

\subsection{Matrices (\pycode{Mats})}

\pycode{Mats} require 2 axis trees: one for the rows of the matrix and one for the columns.
They rely on PETSc \ccode{Mat} objects for the underlying data storage.
To improve performance one should preallocate the matrix by constructing a \pycode{Sparsity} object and doing a simulated run of all the loop expressions so that non-zeros are put in the right places.

Since \pycode{Mats} have two axis trees, two indices are needed when indexing.

\section{The domain-specific language}
\label{sec:dsl}

\subsection{Loop expressions}
% loop expressions, made of a loop index and statements
% can be context-sensitive

% how do they manifest? how do we generate code from them?
% the axes turn into loops - this can be done without mentioning loopy
% maybe have API alongside generated code? what about the axis trees?

\begin{figure}[h]
  \centering

  \hfill
  %
  \begin{subfigure}[t]{.3\textwidth}
    \centering
    \begin{minipage}{.8\textwidth}
      \begin{minted}{python}
        loop(
          p := axes.index(),
          do_something(...),
        )
      \end{minted}
    \end{minipage}
    %
    \vspace{1em}
  \end{subfigure}
  %
  \hfill
  %
  \begin{subfigure}[t]{.38\textwidth}
    \centering
    \begin{minipage}{\textwidth}
      \centering
      \includegraphics{loop_expr_axes.pdf}
    \end{minipage}
  \end{subfigure}
  %
  \hfill
  %
  \begin{subfigure}[t]{.3\textwidth}
    \centering
    \begin{minipage}{.8\textwidth}
      \begin{minted}{python}
        for ia in range(5):
          for ib in range(3):
            do_something(...)
      \end{minted}
    \end{minipage}
    %
    \vspace{1.5em}
  \end{subfigure}
  %
  \hfill

  \caption{
    A simple example of generating code from a loop expression.
    The loop expression (left) loops over axis tree \pycode{axes} and performs some computation (\pycode{do_something}) for each point in the iteration.
    \pycode{axes} is defined to be a two-dimensional linear axis tree with shape \pycode{(5, 3)} and axis labels $a$ and $b$ (middle).
    Pseudocode for the code that is generated from this expression is shown to the right.
    Loop indices \pycode{ia} and \pycode{ib} correspond to looping over axes $a$ and $b$ respectively.
  }
  \label{fig:loop_expr}
\end{figure}

\subsubsection{Context-sensitive loops}

\begin{figure}[h]
  \centering

  \begin{subfigure}[t]{.32\textwidth}
    \centering
    % extra lines to improve position on page
    \begin{minted}{python}
loop(
  p := axes.index(), ...
)


    \end{minted}
    %
    \caption{TODO}
    \label{fig:multi_component_loop_expr_init}
  \end{subfigure}
  %
  \begin{subfigure}[t]{.32\textwidth}
    \centering
    \includegraphics{multi_component_loop_expr_axes.pdf}
    %
    \caption{TODO}
    \label{fig:multi_component_loop_expr_axes}
  \end{subfigure}
  %
  \begin{subfigure}[t]{.32\textwidth}
    \centering
    % extra lines to improve position on page
    \begin{minted}{python}
for ia in range(2):
  for ib in range(3):
    ...

for ia in range(2):
  for ic in range(2):
    ...
    \end{minted}
    %
    \caption{TODO}
    \label{fig:multi_component_loop_expr_codegen}
  \end{subfigure}

  \caption{TODO}
  \label{fig:multi_component_loop_expr}
\end{figure}

\subsection{Kernels}

% kernels
% access descriptors (vague)

\section{Code generation}

\begin{figure}[h]
  \centering
  \includegraphics{codegen_flowchart.pdf}
  \caption{
    The code generation pipeline for the compilation of a loop expression into a callable function.
    The input (``Loop expression") and output (``Compiled function") are shown in blue whilst the intermediate processes are red.
    The dashed line from input expression to output function is included to represent the fact that the compiled function additionally requires data from the input loop expression in order to be usable.
  }
  \label{fig:codegen_flowchart}
\end{figure}

\begin{table}
  \centering

  \begin{tabular}{|c|l|l|}
    \hline
    \textbf{Intent} & \textbf{Pack instruction} & \textbf{Unpack instruction} \\
    \hline
    \pycode{READ} & \pycode{t0[*i] = dat0[*j]} & \tableDash \\
    \hline
    \pycode{WRITE} & \tableDash & \pycode{dat0[*j] = t0[*i]} \\
    \hline
    \pycode{RW} & \pycode{t0[*i] = dat0[*j]} & \pycode{dat0[*j] = t0[*i]} \\
    \hline
    \pycode{INC} & \pycode{t0[*i] = 0} & \pycode{dat0[*j] = dat0[*j] + t0[*i]} \\
    \hline
    \pycode{MIN_WRITE} & \tableDash & \pycode{dat0[*j] = min(dat0[*j], t0[*i])} \\
    \hline
    \pycode{MIN_INC} & \pycode{t0[*i] = 0} & \pycode{dat0[*j] = min(dat0[*j], t0[*i])} \\
    \hline
    \pycode{MAX_WRITE} & \tableDash & \pycode{dat0[*j] = max(dat0[*j], t0[*i])} \\
    \hline
    \pycode{MAX_INC} & \pycode{t0[*i] = 0} & \pycode{dat0[*j] = max(dat0[*j], t0[*i])} \\
    \hline
  \end{tabular}

  \caption{
    Intent values supported by \pyop3 kernels and their corresponding pack/unpack instructions.
    The generated instructions (pack and unpack columns) assume that one is packing from global array \pycode{dat0} into local temporary \pycode{t0}.
    The multi-indices used to index into \pycode{t0} and \pycode{dat0} are represented by \pycode{*i} and \pycode{*j} respectively.
    Table entries marked with a ``\pycode{-}" indicate that no pack/unpack instruction is emitted for this intent.
  }
  \label{tab:intents}
\end{table}

% transformations can be split into functional ones and optimisation ones

% dual role of loop expression: codegen spec *and* data to pass through (ref. figure)

To aid with the explanation, we will take a straightforward loop expression typical of finite element style codes and demonstrate the transformation and lowering stages of the compilation pipeline as they apply to it:

\begin{center}
  \begin{minipage}{.38\textwidth}
    \begin{minted}{python}
      loop(
        p := a.index(),
        kernel(dat0[map0(p)], dat1[p]),
      )
    \end{minted}
  \end{minipage}
\end{center}

In this loop expression a number of terms require further explanation.
Firstly, \pycode{dat0} and \pycode{dat1} are defined to be arrays with shape \pycode{(8, 3)} and \pycode{(5,)} respectively, with their axis trees appearing as follows:

...
% x,y and a

The axis tree that forms the loop index (\pycode{a}) is the same as the one used to construct \pycode{dat1}.
We therefore expect that the generated loop will have the following structure (since axis $a$ has 5 entries):

\begin{center}
  \begin{minipage}{.25\textwidth}
    \begin{minted}{python}
      for ia in range(5):
        kernel(...)
    \end{minted}
  \end{minipage}
\end{center}

% how are they indexed? what are the temporary shapes?
% map0 means that dat0[map0(p)] has 6 entries, implicit slice

Lastly, the local kernel (\pycode{kernel}) is defined to be some function taking two arguments with size 6 and intent \pycode{READ}, and size 1 and intent \pycode{INC} respectively.

\subsection{Loop expression transformations}

\begin{figure}
  \centering

  \begin{subfigure}[t]{.3\textwidth}
    \includegraphics{loop_expr_tree_initial.pdf}
    \caption{The initial loop expression tree.}
    \label{fig:loop_expr_tree_transform_initial}
  \end{subfigure}
  %
  \hfill
  %
  \begin{subfigure}[t]{.68\textwidth}
    \includegraphics{loop_expr_tree_expanded.pdf}
    \caption{The transformed loop expression tree where the implicit pack and unpack instructions have been made explicit via conversion to \pycode{write} and \pycode{inc} instructions.}
    \label{fig:loop_expr_tree_transform_expanded}
  \end{subfigure}

  \caption{
    The expression tree transformation expanding implicit pack and unpack instructions for \pycode{kernel}, which has argument intents of \pycode{READ} and \pycode{INC} for its first and second argument respectively.
  }
  \label{fig:loop_expr_tree_transform}
\end{figure}

% \paragraph{Loop expression transformations}

\begin{figure}
  \centering
  \begin{minipage}{.8\textwidth}
    \inputminted{text}{./scripts/artefacts/codegen_example_loopy_kernel_tidy.txt}
  \end{minipage}
  \caption{
    Abbreviated textual representation of the loopy kernel generated for expression XXX.
  }
  \label{lst:codegen_example_loopy_kernel}
\end{figure}

\end{document}
