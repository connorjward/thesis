\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Introduction}
\label{chapter:introduction}

% TODO: Review notes from previous meetings where motivation is discussed.

% * (numerically) solving PDEs is very important for lots of things:
%   * climate
%   * manufacturing
%   * fluids...
%   * ???

% * If a computational scientist wants to develop a new application they have two
% options available to them:
%   * write a new code from scratch, VERY slow (years of work "reinventing the
%     wheel", not a domain specialist, poor performance...)
%   * use a pre-existing framework

% These frameworks target different levels of abstraction...
% * "on the one hand..." a high level of abstraction lets one express problems concisely, quick to iterate
%    * Composability!
%    * Separation of concerns: Domain specialists can focus on the things they do best.
%      Crucially it lowers the barrier to entry for scientists to do novel work.
%    * Can do some really complicated optimisations that would be very hard to reason about
%      by hand
%      * with codegen, i.e. compilers, one can do some really amazing optimisations not available
%      * to library interfaces and traditional compilers. In particular cross-loop optimisations?
%      * Also data layout/memory bandwidth minimising optimisations.
%      * this is because DSLs provide a high-level representation of the problem where complicated problems may be straightforwardly expressed.
%      * It is an example of an inspector-executor application.
%      * key principle: optimisations are easy, synthesis is hard. Level of abstraction
%      * facilitates memory optimisations.

% * "However..." abstractions also lock one into a particular way of working. Limitations in
%   the abstraction prohibit new methods from being developed,. Assumptions made when the
%   code was originally written shackle things.
% * One way out of this is to have "escape hatches" in your abstraction. Exponential
%   explosion of implementation complexity (not composable). Maybe feature X and feature Y work, but both together? 
%   As the number of features increases this becomes an enormous problem to maintain.
%   E.g. porting to GPUs often requires substantial rewrites of the underlying code
%   (years of developer time, cite PETSc?).

% In this work we will present pyop3, a new abstraction for mesh iteration
% * mesh iteration is ubiquitous in numerical solution of PDEs (FDM, FEM, FVM)
% * pyop3 is a DSL
% * pyop3 was created to address shortcomings in its predecessor PyOP2.
% * more powerful (expressive), can describe more things, more flexible about data layouts, easier to use (better API)
% This increased expressiveness is beneficial as it enables higher-level DSLs (e.g. UFL) to express more problems without having to resort to abstraction-breaking internal code changes.
% "pyop3 is a new abstraction that better captures the semantics of what it means to execute over a mesh"
% As a consequence, implementing novel numerical methods that would have previously been infeasible are now tractable.

The remainder of this paper is laid out as follows\dots

\end{document}
