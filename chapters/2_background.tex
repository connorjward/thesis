\documentclass[thesis]{subfiles}

\begin{document}

\chapter{Background}
\label{chapter:background}

\section{The finite element method}

Prior to the development of a more general approach for applying computations across an unstructured mesh, it is instructive to review a classical example of such a calculation: \textit{finite element assembly}.

\subsection{An example of a complicated stencil function: solving the Stokes equations using the finite element method}

For a moderately complex stencil operation that we will refer to throughout this thesis we consider solving the Stokes equations using the finite element method (FEM)~\parencite{larsonFiniteElementMethod2013}.
The Stokes equations are a linearisation of the Navier-Stokes equations and are used to describe fluid flow for laminar (slow and calm) media.
For domain $\Omega$ they are given by

% split into sub-equations that may be separately labelled
\begin{align}
  \label{strong_stokes_equation}
  - \nu \Delta u + \nabla p &= f \quad \textrm{in} \ \Omega, \\
  \nabla \cdot u &= 0 \quad \textrm{in} \ \Omega, \\
\end{align}

where $u$ is the fluid velocity, $p$ the pressure, $\nu$ the viscosity and $f$ is a known forcing term.
We also prescribe Dirichlet boundary conditions for the velocity across the entire boundary

\begin{equation}
  \label{strong_stokes_equation_bc}
  u = g \quad \textrm{on} \ \Gamma. 
\end{equation}

For the finite element method we seek the solution to the \textit{variational}, or \textit{weak}, formulation of these equations.
These are obtained by multiplying each equation by a suitable \textit{test function} and integrating over the domain.
% should use sub-equation
For \ref{strong_stokes_equation}, with $v$ as the test function and integrating by parts, this gives

% taken from https://nbviewer.org/github/firedrakeproject/firedrake/blob/master/docs/notebooks/06-pde-constrained-optimisation.ipynb
\begin{equation}
  \int \nu \nabla u : \nabla v \textrm{d}\Omega
  - \int p \nabla \cdot v \textrm{d}\Omega
  = \int f \cdot v \textrm{d}\Omega
\end{equation}

% TODO Explain reduced function spaces better to motivate V vs V_0
% Or, just say "prescribing Dirichlet boundary conditions on the full surface gives..."
Note that the surface terms from the integration by parts can be dropped since $v$ is defined to be zero at Dirichlet nodes.

For the second equation we simply get

\begin{equation}
  \int q \, \nabla \cdot u \textrm{d}\Omega = 0.
\end{equation}

In order for these equations to be well-posed we require that the functions $u$, $v$, $p$ and $q$ be drawn from appropriate function spaces\dots

% must be P3? I think must be dimension + 1 (see papers about counting DoFs by multigrid man)

% now introduce discrete function spaces V_h and Q_h and convert equations to basis function form
% with coefficients for u and p
  % the coefficients for v may be ignored as they cancel
% this is a block matrix vector system, test functions are rows and trial functions are columns
% (see Homolya thesis)

% *** Associating DoFs with mesh entities *** (new section)
% what constraints are there on the function spaces? H1 and L2
% specify the chosen element pair with Taylor-Hood (vec Pk, Pk-1, in this case k=3)?
% show what the basis functions look like, *use defelement*
% in FEM, basis functions overlap with points in closure(support(p)) - adjacency.

% ---

% Ciarlet element definition

% now we have discrete basis function form, convert to a cellwise sum of integrals
% this is a stencil calculation - for each cell, compute the contribution of all basis
% functions that have support on the cell. This is closure(cell) - a stencil! Applies to both LHS and RHS

% can show my pretty diagram now!

% explain discontinuous case? interior facets? separate section.
% "just" a different stencil. find an example integral with, say, a jump term.
% could have a diagram for this too!

  % continuity between cells done by associating DoFs with vertices and edges etc

% NOTE: Could definitely discuss DMPlex here
% \subsubsection{A software aside: Unstructured meshing with PETSc DMPlex}?

% *** End this section by discussing how there are weird looking data structures and that we need to iterate over them cell by cell
% iteration can be shown as pseudo-code
% Also make clear that the mesh is numbered so vertex and edge dofs are interleaved.
% also that it is distributed (parallel)

% "Domain-specific languages"?
% "Domain-specific languages for array computations"?
% "Abstractions for array computations"?
% This section is really talking about compilers and JIT-ing
\section{Code generation and domain-specific languages for scientific computing}

% why is code generation useful?
% We need to be able to express problems in some platform
% agnostic language that gets compiled to different platforms and can
% apply platform specific optimisations. Needs to be fast and productive and portable.
% can be super fast!
% * Halide?
% * Spiral?
% * BLIS?
% * FFTW?

% NOTE: Not completely sure how to arrange the below bit

% inspector-executor model. cite Saltz and Strout
% two programs, an inspector that generates a schedule, and an executor that uses it. Executor
% is a transformed original program.
% these aim to improve data locality and parallelisation opportunities.
% important point is that I/E strategies utilise runtime information to generate optimal schedules
% this is very important for unstructured applications where the compilers would have a really hard time!
\cite{stroutSparsePolyhedralFramework2018} % review article
\cite{mirchandaneyPrinciplesRuntimeSupport1988} % old (general purpose) example
\cite{arenazInspectorExecutorAlgorithmIrregular2004} % fem example but specifically parallelisation
% perhaps also cite Luporini for sparse tiling? yes I think that would be good.
% Interesting note: composing inspector-executor transformations is difficult.
% see "The Sparse Polyhedral Framework: Composing Compiler-Generated Inspector-Executor Code"
% DSLs like loopy and pyop3 can make this easier to handle.
% mesh numbering is an example of an inspector-executor thing.
% so is determining core and owned to overlap communication and computation
% DSLs help a lot to implement this sort of thing because transformations can be a lot easier to
% express using a high-level representation.

% Therefore need a nice abstraction for expressing and reasoning about the problem: DSL

\subsection{Abstractions for array computations}

% There are a million and one compilers for handling arrays
% e.g. polyhedral model, TACO, Tiramisu, einsum notation

% however, they are not sufficient for our purposes because they all use N-dimensional array/tensor layouts.
% mesh data is more heterogeneous than that so for things to work need to discard information about the topological relations between the mesh and the data

% it can be made more complicated with things like TACO where the layers can differ, but still not sufficient as there are intra-layer differences
% also sparsity (SPF), ragged (AwkwardArray, PPMD), distributed (DistArray, Chapel)

\subsection{Abstractions for mesh-like data layouts}

% The following all fix this problem and can describe the right kind of data layouts
%NOTE: could try having a checklist of features?

% OP2: \cite{mudaligeOP2ActiveLibrary2012}
% PyOP2
% the simplest solution, use indirection maps
% works in parallel, not composable/expressive
% sophisticated overlapping of computation and communication
% does not need a mesh object, can use external software

% Liszt
% \cite{devitoLisztDomainSpecific2011}
% * dead project (since 2013)
% * works in parallel, but custom mesh etc so has to do its own partitioning etc
% * mesh is not dimension-independent
% * embedded in Scala
% * (needs a mesh)

% Simit
% https://simit-lang.org/
% \cite{kjolstadSimitLanguagePhysical2016}
% * dead project
% * C++ code
% * does not work on multi-core machines, does work with GPUs
% * hypergraph is like DMPlex, has a custom mesh implementation
% * stores data as "hypergraph sets with tensor fields" - associates data with topological entities
% * has "dual" representations of mesh data structures: as hypergraphs and as tensors. pyop3 effectively unifies the two
% * (needs a mesh - sort of)

% Ebb
% http://ebblang.org/
% * dead project
% \cite{bernsteinEbbDSLPhysical2016}
% uses a relational database model to describe mesh connectivity
% uses a layer model to separate data structure definition from simulation code
% * (doesn't need a mesh)
% * embedded in lua
% * not multi-core

% AoS-SoA etc? (taichi)
\textbf{Taichi} is a programming language embedded in C\+\+ for operating on complex data structures~\cite{huTaichiLanguageHighperformance2019}.
Just like \pyop3, Taichi declares data structures hierarchically and the data layout is kept distinct from the operations applied to them.
Taichi has no concept of a mesh, and it does not work on distributed machines.
% https://www.taichi-lang.org/
% very successful!

% summarise - these all have limitations so we will make a new one based on DMPlex and PyOP2

\section{An abstraction for unstructured meshes: PETSc DMPlex}

% generally introduce PETSc as well in a few sentences (matrices, vectors, solvers, massively parallel, GPU support)
% * DMPlex
  % * layouts with petscsection

% data layouts on meshes
  % stencils
    % stencils in dmplex, topological query language

% TODO: MUST talk about mesh renumbering here, also parallel stuff (SF)
% No, parallel can be later, just mention here that the mesh is distributed and
% point to the parallel chapter.

% \subsubsection{Representing data layouts with DMPlex}
%
% DMPlex represents a mesh as a set of points where the points are divided into \textit{strata} (cells, edges, vertices, etc).
% These points are connected in a graph (Hasse diagram) and a rich set of queries can be used to determine the right adjacencies needed for things like the finite element method.
%
% In order to associated data with these mesh points, a typical PETSc application will construct a PETSc \ccode{Section}.
% These are simple CSR-like (?) data structures that encode a data layout by associating a particular number of DoFs with each mesh point.
% Sections are a powerful tool for describing data layouts but they have a number of limitations:
%
% \begin{itemize}
%   \item
%     Sections are fully ragged.
%     They only store DoF information per point in a completely unstructured way and are incapable of knowing, say, that every cell in the mesh stores exactly one DoF.
%     This can prohibit the compiler from making certain optimisations (e.g. loop unrolling) that it would have been able to do were it to know of a constant loop extent.
%     Additionally, this variable size increases memory pressure as redundant arrays of constant sizes need to be streamed through memory.
%
%   \item
%     DoFs per point are treated as a flat array.
%     This means that shape information is lost for, say, vector-valued functions.
% \end{itemize}
%
% With PETSc/DMPlex, the P3 DoF layout would be represented as shown in Figure~\ref{???}.
% % figure showing PetscSection info

% End the section by showing some pseudocode for FEM assembly


\section{An execution model: PyOP2}
% and why OP2 not Liszt?
% why chosen? interop with PETSc, good for FEM, works in parallel...

% integrated with Firedrake (popular FEM lib)

% loopy
% PyOP2 limitations
% explain loopy's programming model of kernel plus transformations. It is fundamentally
% very similar to how high level mathematical DSLs like UFL work except for loops.

% \subsubsection{Data layouts in \pyop2}
%
% \pyop2 takes a very different approach to describing data layouts to DMPlex.
% Firstly, it has no conception of what a mesh is and it deals solely with \textit{sets} and \textit{mappings between sets}.
% The rich query language provided by DMPlex is therefore unavailable and the task of determining the right adjacency maps is passed to the user.
%


% TODO: I don't know where to put this bit? where we talk about N-dimensional arrays? could explain concepts of shape and indexing? Specific syntax can then be described in later sections...
\subsection{An interface for multi-dimensional data: numpy}

% (cite paper, search for "citing numpy")
% although not a JIT, numpy is important for introducing ergonomic ways of
% expressing array computations
% there are some numpy JIT options out there: JAX, pytato, pytorch?



\end{document}
